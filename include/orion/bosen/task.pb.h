// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: task.proto

#ifndef PROTOBUF_task_2eproto__INCLUDED
#define PROTOBUF_task_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace orion {
namespace bosen {
namespace task {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_task_2eproto();
void protobuf_AssignDesc_task_2eproto();
void protobuf_ShutdownFile_task_2eproto();

class ExecuteCode;
class TableDep;
class ConcreteBaseTable;
class VirtualBaseTable;
class CallFunc;
class CreateDistArray;
class EvalExpr;

enum TableDepType {
  PIPELINED = 1,
  RANDOM_ACCESS = 2
};
bool TableDepType_IsValid(int value);
const TableDepType TableDepType_MIN = PIPELINED;
const TableDepType TableDepType_MAX = RANDOM_ACCESS;
const int TableDepType_ARRAYSIZE = TableDepType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TableDepType_descriptor();
inline const ::std::string& TableDepType_Name(TableDepType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TableDepType_descriptor(), value);
}
inline bool TableDepType_Parse(
    const ::std::string& name, TableDepType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TableDepType>(
    TableDepType_descriptor(), name, value);
}
enum ReadWrite {
  READ_ONLY = 1,
  WRITE_ONLY = 2,
  READ_WRITE = 3
};
bool ReadWrite_IsValid(int value);
const ReadWrite ReadWrite_MIN = READ_ONLY;
const ReadWrite ReadWrite_MAX = READ_WRITE;
const int ReadWrite_ARRAYSIZE = ReadWrite_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReadWrite_descriptor();
inline const ::std::string& ReadWrite_Name(ReadWrite value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReadWrite_descriptor(), value);
}
inline bool ReadWrite_Parse(
    const ::std::string& name, ReadWrite* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReadWrite>(
    ReadWrite_descriptor(), name, value);
}
enum Repetition {
  ONE_PARTITION = 1,
  ALL_LOCAL_PARTITIONS = 2,
  ALL_PARTITIONS = 3
};
bool Repetition_IsValid(int value);
const Repetition Repetition_MIN = ONE_PARTITION;
const Repetition Repetition_MAX = ALL_PARTITIONS;
const int Repetition_ARRAYSIZE = Repetition_MAX + 1;

const ::google::protobuf::EnumDescriptor* Repetition_descriptor();
inline const ::std::string& Repetition_Name(Repetition value) {
  return ::google::protobuf::internal::NameOfEnum(
    Repetition_descriptor(), value);
}
inline bool Repetition_Parse(
    const ::std::string& name, Repetition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Repetition>(
    Repetition_descriptor(), name, value);
}
enum PartitionScheme {
  STATIC = 1,
  DYNAMIC = 2,
  RANDOM = 3
};
bool PartitionScheme_IsValid(int value);
const PartitionScheme PartitionScheme_MIN = STATIC;
const PartitionScheme PartitionScheme_MAX = RANDOM;
const int PartitionScheme_ARRAYSIZE = PartitionScheme_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartitionScheme_descriptor();
inline const ::std::string& PartitionScheme_Name(PartitionScheme value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartitionScheme_descriptor(), value);
}
inline bool PartitionScheme_Parse(
    const ::std::string& name, PartitionScheme* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartitionScheme>(
    PartitionScheme_descriptor(), name, value);
}
enum BaseTableType {
  VIRTUAL = 1,
  CONCRETE = 2
};
bool BaseTableType_IsValid(int value);
const BaseTableType BaseTableType_MIN = VIRTUAL;
const BaseTableType BaseTableType_MAX = CONCRETE;
const int BaseTableType_ARRAYSIZE = BaseTableType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BaseTableType_descriptor();
inline const ::std::string& BaseTableType_Name(BaseTableType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BaseTableType_descriptor(), value);
}
inline bool BaseTableType_Parse(
    const ::std::string& name, BaseTableType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BaseTableType>(
    BaseTableType_descriptor(), name, value);
}
enum DistArrayParentType {
  TEXT_FILE = 1,
  DIST_ARRAY = 2,
  INIT = 3
};
bool DistArrayParentType_IsValid(int value);
const DistArrayParentType DistArrayParentType_MIN = TEXT_FILE;
const DistArrayParentType DistArrayParentType_MAX = INIT;
const int DistArrayParentType_ARRAYSIZE = DistArrayParentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DistArrayParentType_descriptor();
inline const ::std::string& DistArrayParentType_Name(DistArrayParentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DistArrayParentType_descriptor(), value);
}
inline bool DistArrayParentType_Parse(
    const ::std::string& name, DistArrayParentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DistArrayParentType>(
    DistArrayParentType_descriptor(), name, value);
}
enum DistArrayInitType {
  EMPTY = 1,
  UNIFORM_RANDOM = 2
};
bool DistArrayInitType_IsValid(int value);
const DistArrayInitType DistArrayInitType_MIN = EMPTY;
const DistArrayInitType DistArrayInitType_MAX = UNIFORM_RANDOM;
const int DistArrayInitType_ARRAYSIZE = DistArrayInitType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DistArrayInitType_descriptor();
inline const ::std::string& DistArrayInitType_Name(DistArrayInitType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DistArrayInitType_descriptor(), value);
}
inline bool DistArrayInitType_Parse(
    const ::std::string& name, DistArrayInitType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DistArrayInitType>(
    DistArrayInitType_descriptor(), name, value);
}
// ===================================================================

class ExecuteCode : public ::google::protobuf::Message {
 public:
  ExecuteCode();
  virtual ~ExecuteCode();

  ExecuteCode(const ExecuteCode& from);

  inline ExecuteCode& operator=(const ExecuteCode& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecuteCode& default_instance();

  void Swap(ExecuteCode* other);

  // implements Message ----------------------------------------------

  ExecuteCode* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecuteCode& from);
  void MergeFrom(const ExecuteCode& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // required int32 result_type = 2;
  inline bool has_result_type() const;
  inline void clear_result_type();
  static const int kResultTypeFieldNumber = 2;
  inline ::google::protobuf::int32 result_type() const;
  inline void set_result_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:orion.bosen.task.ExecuteCode)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_result_type();
  inline void clear_has_result_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* code_;
  ::google::protobuf::int32 result_type_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static ExecuteCode* default_instance_;
};
// -------------------------------------------------------------------

class TableDep : public ::google::protobuf::Message {
 public:
  TableDep();
  virtual ~TableDep();

  TableDep(const TableDep& from);

  inline TableDep& operator=(const TableDep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableDep& default_instance();

  void Swap(TableDep* other);

  // implements Message ----------------------------------------------

  TableDep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableDep& from);
  void MergeFrom(const TableDep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 table_id = 1;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 1;
  inline ::google::protobuf::int32 table_id() const;
  inline void set_table_id(::google::protobuf::int32 value);

  // required .orion.bosen.task.TableDepType dep_type = 2;
  inline bool has_dep_type() const;
  inline void clear_dep_type();
  static const int kDepTypeFieldNumber = 2;
  inline ::orion::bosen::task::TableDepType dep_type() const;
  inline void set_dep_type(::orion::bosen::task::TableDepType value);

  // required .orion.bosen.task.ReadWrite read_write = 3;
  inline bool has_read_write() const;
  inline void clear_read_write();
  static const int kReadWriteFieldNumber = 3;
  inline ::orion::bosen::task::ReadWrite read_write() const;
  inline void set_read_write(::orion::bosen::task::ReadWrite value);

  // optional string function_compute_dep = 4;
  inline bool has_function_compute_dep() const;
  inline void clear_function_compute_dep();
  static const int kFunctionComputeDepFieldNumber = 4;
  inline const ::std::string& function_compute_dep() const;
  inline void set_function_compute_dep(const ::std::string& value);
  inline void set_function_compute_dep(const char* value);
  inline void set_function_compute_dep(const char* value, size_t size);
  inline ::std::string* mutable_function_compute_dep();
  inline ::std::string* release_function_compute_dep();
  inline void set_allocated_function_compute_dep(::std::string* function_compute_dep);

  // @@protoc_insertion_point(class_scope:orion.bosen.task.TableDep)
 private:
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_dep_type();
  inline void clear_has_dep_type();
  inline void set_has_read_write();
  inline void clear_has_read_write();
  inline void set_has_function_compute_dep();
  inline void clear_has_function_compute_dep();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 table_id_;
  int dep_type_;
  ::std::string* function_compute_dep_;
  int read_write_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static TableDep* default_instance_;
};
// -------------------------------------------------------------------

class ConcreteBaseTable : public ::google::protobuf::Message {
 public:
  ConcreteBaseTable();
  virtual ~ConcreteBaseTable();

  ConcreteBaseTable(const ConcreteBaseTable& from);

  inline ConcreteBaseTable& operator=(const ConcreteBaseTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConcreteBaseTable& default_instance();

  void Swap(ConcreteBaseTable* other);

  // implements Message ----------------------------------------------

  ConcreteBaseTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConcreteBaseTable& from);
  void MergeFrom(const ConcreteBaseTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 table_id = 1;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 1;
  inline ::google::protobuf::int32 table_id() const;
  inline void set_table_id(::google::protobuf::int32 value);

  // required .orion.bosen.task.PartitionScheme partition_scheme = 2;
  inline bool has_partition_scheme() const;
  inline void clear_partition_scheme();
  static const int kPartitionSchemeFieldNumber = 2;
  inline ::orion::bosen::task::PartitionScheme partition_scheme() const;
  inline void set_partition_scheme(::orion::bosen::task::PartitionScheme value);

  // optional uint64 partition_size = 3;
  inline bool has_partition_size() const;
  inline void clear_partition_size();
  static const int kPartitionSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 partition_size() const;
  inline void set_partition_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:orion.bosen.task.ConcreteBaseTable)
 private:
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_partition_scheme();
  inline void clear_has_partition_scheme();
  inline void set_has_partition_size();
  inline void clear_has_partition_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 table_id_;
  int partition_scheme_;
  ::google::protobuf::uint64 partition_size_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static ConcreteBaseTable* default_instance_;
};
// -------------------------------------------------------------------

class VirtualBaseTable : public ::google::protobuf::Message {
 public:
  VirtualBaseTable();
  virtual ~VirtualBaseTable();

  VirtualBaseTable(const VirtualBaseTable& from);

  inline VirtualBaseTable& operator=(const VirtualBaseTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VirtualBaseTable& default_instance();

  void Swap(VirtualBaseTable* other);

  // implements Message ----------------------------------------------

  VirtualBaseTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VirtualBaseTable& from);
  void MergeFrom(const VirtualBaseTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:orion.bosen.task.VirtualBaseTable)
 private:
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 size_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static VirtualBaseTable* default_instance_;
};
// -------------------------------------------------------------------

class CallFunc : public ::google::protobuf::Message {
 public:
  CallFunc();
  virtual ~CallFunc();

  CallFunc(const CallFunc& from);

  inline CallFunc& operator=(const CallFunc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CallFunc& default_instance();

  void Swap(CallFunc* other);

  // implements Message ----------------------------------------------

  CallFunc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CallFunc& from);
  void MergeFrom(const CallFunc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string function_name = 1;
  inline bool has_function_name() const;
  inline void clear_function_name();
  static const int kFunctionNameFieldNumber = 1;
  inline const ::std::string& function_name() const;
  inline void set_function_name(const ::std::string& value);
  inline void set_function_name(const char* value);
  inline void set_function_name(const char* value, size_t size);
  inline ::std::string* mutable_function_name();
  inline ::std::string* release_function_name();
  inline void set_allocated_function_name(::std::string* function_name);

  // required .orion.bosen.task.BaseTableType base_table_type = 2;
  inline bool has_base_table_type() const;
  inline void clear_base_table_type();
  static const int kBaseTableTypeFieldNumber = 2;
  inline ::orion::bosen::task::BaseTableType base_table_type() const;
  inline void set_base_table_type(::orion::bosen::task::BaseTableType value);

  // optional .orion.bosen.task.VirtualBaseTable virtual_base_table = 3;
  inline bool has_virtual_base_table() const;
  inline void clear_virtual_base_table();
  static const int kVirtualBaseTableFieldNumber = 3;
  inline const ::orion::bosen::task::VirtualBaseTable& virtual_base_table() const;
  inline ::orion::bosen::task::VirtualBaseTable* mutable_virtual_base_table();
  inline ::orion::bosen::task::VirtualBaseTable* release_virtual_base_table();
  inline void set_allocated_virtual_base_table(::orion::bosen::task::VirtualBaseTable* virtual_base_table);

  // optional .orion.bosen.task.ConcreteBaseTable concrete_base_table = 4;
  inline bool has_concrete_base_table() const;
  inline void clear_concrete_base_table();
  static const int kConcreteBaseTableFieldNumber = 4;
  inline const ::orion::bosen::task::ConcreteBaseTable& concrete_base_table() const;
  inline ::orion::bosen::task::ConcreteBaseTable* mutable_concrete_base_table();
  inline ::orion::bosen::task::ConcreteBaseTable* release_concrete_base_table();
  inline void set_allocated_concrete_base_table(::orion::bosen::task::ConcreteBaseTable* concrete_base_table);

  // repeated .orion.bosen.task.TableDep deps = 5;
  inline int deps_size() const;
  inline void clear_deps();
  static const int kDepsFieldNumber = 5;
  inline const ::orion::bosen::task::TableDep& deps(int index) const;
  inline ::orion::bosen::task::TableDep* mutable_deps(int index);
  inline ::orion::bosen::task::TableDep* add_deps();
  inline const ::google::protobuf::RepeatedPtrField< ::orion::bosen::task::TableDep >&
      deps() const;
  inline ::google::protobuf::RepeatedPtrField< ::orion::bosen::task::TableDep >*
      mutable_deps();

  // required .orion.bosen.task.Repetition repetition = 6;
  inline bool has_repetition() const;
  inline void clear_repetition();
  static const int kRepetitionFieldNumber = 6;
  inline ::orion::bosen::task::Repetition repetition() const;
  inline void set_repetition(::orion::bosen::task::Repetition value);

  // required uint64 num_iterations = 7;
  inline bool has_num_iterations() const;
  inline void clear_num_iterations();
  static const int kNumIterationsFieldNumber = 7;
  inline ::google::protobuf::uint64 num_iterations() const;
  inline void set_num_iterations(::google::protobuf::uint64 value);

  // required int32 result_type = 8;
  inline bool has_result_type() const;
  inline void clear_result_type();
  static const int kResultTypeFieldNumber = 8;
  inline ::google::protobuf::int32 result_type() const;
  inline void set_result_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:orion.bosen.task.CallFunc)
 private:
  inline void set_has_function_name();
  inline void clear_has_function_name();
  inline void set_has_base_table_type();
  inline void clear_has_base_table_type();
  inline void set_has_virtual_base_table();
  inline void clear_has_virtual_base_table();
  inline void set_has_concrete_base_table();
  inline void clear_has_concrete_base_table();
  inline void set_has_repetition();
  inline void clear_has_repetition();
  inline void set_has_num_iterations();
  inline void clear_has_num_iterations();
  inline void set_has_result_type();
  inline void clear_has_result_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* function_name_;
  ::orion::bosen::task::VirtualBaseTable* virtual_base_table_;
  ::orion::bosen::task::ConcreteBaseTable* concrete_base_table_;
  int base_table_type_;
  int repetition_;
  ::google::protobuf::RepeatedPtrField< ::orion::bosen::task::TableDep > deps_;
  ::google::protobuf::uint64 num_iterations_;
  ::google::protobuf::int32 result_type_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static CallFunc* default_instance_;
};
// -------------------------------------------------------------------

class CreateDistArray : public ::google::protobuf::Message {
 public:
  CreateDistArray();
  virtual ~CreateDistArray();

  CreateDistArray(const CreateDistArray& from);

  inline CreateDistArray& operator=(const CreateDistArray& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateDistArray& default_instance();

  void Swap(CreateDistArray* other);

  // implements Message ----------------------------------------------

  CreateDistArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateDistArray& from);
  void MergeFrom(const CreateDistArray& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required .orion.bosen.task.DistArrayParentType parent_type = 2;
  inline bool has_parent_type() const;
  inline void clear_parent_type();
  static const int kParentTypeFieldNumber = 2;
  inline ::orion::bosen::task::DistArrayParentType parent_type() const;
  inline void set_parent_type(::orion::bosen::task::DistArrayParentType value);

  // required bool flatten_results = 3;
  inline bool has_flatten_results() const;
  inline void clear_flatten_results();
  static const int kFlattenResultsFieldNumber = 3;
  inline bool flatten_results() const;
  inline void set_flatten_results(bool value);

  // required bool value_only = 4;
  inline bool has_value_only() const;
  inline void clear_value_only();
  static const int kValueOnlyFieldNumber = 4;
  inline bool value_only() const;
  inline void set_value_only(bool value);

  // required bool parse = 5;
  inline bool has_parse() const;
  inline void clear_parse();
  static const int kParseFieldNumber = 5;
  inline bool parse() const;
  inline void set_parse(bool value);

  // required uint64 num_dims = 6;
  inline bool has_num_dims() const;
  inline void clear_num_dims();
  static const int kNumDimsFieldNumber = 6;
  inline ::google::protobuf::uint64 num_dims() const;
  inline void set_num_dims(::google::protobuf::uint64 value);

  // required int32 value_type = 7;
  inline bool has_value_type() const;
  inline void clear_value_type();
  static const int kValueTypeFieldNumber = 7;
  inline ::google::protobuf::int32 value_type() const;
  inline void set_value_type(::google::protobuf::int32 value);

  // optional string file_path = 8;
  inline bool has_file_path() const;
  inline void clear_file_path();
  static const int kFilePathFieldNumber = 8;
  inline const ::std::string& file_path() const;
  inline void set_file_path(const ::std::string& value);
  inline void set_file_path(const char* value);
  inline void set_file_path(const char* value, size_t size);
  inline ::std::string* mutable_file_path();
  inline ::std::string* release_file_path();
  inline void set_allocated_file_path(::std::string* file_path);

  // optional int32 parent_id = 9;
  inline bool has_parent_id() const;
  inline void clear_parent_id();
  static const int kParentIdFieldNumber = 9;
  inline ::google::protobuf::int32 parent_id() const;
  inline void set_parent_id(::google::protobuf::int32 value);

  // optional .orion.bosen.task.DistArrayInitType init_type = 10;
  inline bool has_init_type() const;
  inline void clear_init_type();
  static const int kInitTypeFieldNumber = 10;
  inline ::orion::bosen::task::DistArrayInitType init_type() const;
  inline void set_init_type(::orion::bosen::task::DistArrayInitType value);

  // optional int32 parser_func_module = 11;
  inline bool has_parser_func_module() const;
  inline void clear_parser_func_module();
  static const int kParserFuncModuleFieldNumber = 11;
  inline ::google::protobuf::int32 parser_func_module() const;
  inline void set_parser_func_module(::google::protobuf::int32 value);

  // optional string parser_func_name = 12;
  inline bool has_parser_func_name() const;
  inline void clear_parser_func_name();
  static const int kParserFuncNameFieldNumber = 12;
  inline const ::std::string& parser_func_name() const;
  inline void set_parser_func_name(const ::std::string& value);
  inline void set_parser_func_name(const char* value);
  inline void set_parser_func_name(const char* value, size_t size);
  inline ::std::string* mutable_parser_func_name();
  inline ::std::string* release_parser_func_name();
  inline void set_allocated_parser_func_name(::std::string* parser_func_name);

  // @@protoc_insertion_point(class_scope:orion.bosen.task.CreateDistArray)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_parent_type();
  inline void clear_has_parent_type();
  inline void set_has_flatten_results();
  inline void clear_has_flatten_results();
  inline void set_has_value_only();
  inline void clear_has_value_only();
  inline void set_has_parse();
  inline void clear_has_parse();
  inline void set_has_num_dims();
  inline void clear_has_num_dims();
  inline void set_has_value_type();
  inline void clear_has_value_type();
  inline void set_has_file_path();
  inline void clear_has_file_path();
  inline void set_has_parent_id();
  inline void clear_has_parent_id();
  inline void set_has_init_type();
  inline void clear_has_init_type();
  inline void set_has_parser_func_module();
  inline void clear_has_parser_func_module();
  inline void set_has_parser_func_name();
  inline void clear_has_parser_func_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  int parent_type_;
  bool flatten_results_;
  bool value_only_;
  bool parse_;
  ::google::protobuf::int32 value_type_;
  ::google::protobuf::uint64 num_dims_;
  ::std::string* file_path_;
  ::google::protobuf::int32 parent_id_;
  int init_type_;
  ::std::string* parser_func_name_;
  ::google::protobuf::int32 parser_func_module_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static CreateDistArray* default_instance_;
};
// -------------------------------------------------------------------

class EvalExpr : public ::google::protobuf::Message {
 public:
  EvalExpr();
  virtual ~EvalExpr();

  EvalExpr(const EvalExpr& from);

  inline EvalExpr& operator=(const EvalExpr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EvalExpr& default_instance();

  void Swap(EvalExpr* other);

  // implements Message ----------------------------------------------

  EvalExpr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EvalExpr& from);
  void MergeFrom(const EvalExpr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes serialized_expr = 1;
  inline bool has_serialized_expr() const;
  inline void clear_serialized_expr();
  static const int kSerializedExprFieldNumber = 1;
  inline const ::std::string& serialized_expr() const;
  inline void set_serialized_expr(const ::std::string& value);
  inline void set_serialized_expr(const char* value);
  inline void set_serialized_expr(const void* value, size_t size);
  inline ::std::string* mutable_serialized_expr();
  inline ::std::string* release_serialized_expr();
  inline void set_allocated_serialized_expr(::std::string* serialized_expr);

  // required int32 result_type = 2;
  inline bool has_result_type() const;
  inline void clear_result_type();
  static const int kResultTypeFieldNumber = 2;
  inline ::google::protobuf::int32 result_type() const;
  inline void set_result_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:orion.bosen.task.EvalExpr)
 private:
  inline void set_has_serialized_expr();
  inline void clear_has_serialized_expr();
  inline void set_has_result_type();
  inline void clear_has_result_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* serialized_expr_;
  ::google::protobuf::int32 result_type_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static EvalExpr* default_instance_;
};
// ===================================================================


// ===================================================================

// ExecuteCode

// required string code = 1;
inline bool ExecuteCode::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecuteCode::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecuteCode::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecuteCode::clear_code() {
  if (code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& ExecuteCode::code() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.ExecuteCode.code)
  return *code_;
}
inline void ExecuteCode::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(value);
  // @@protoc_insertion_point(field_set:orion.bosen.task.ExecuteCode.code)
}
inline void ExecuteCode::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(value);
  // @@protoc_insertion_point(field_set_char:orion.bosen.task.ExecuteCode.code)
}
inline void ExecuteCode::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:orion.bosen.task.ExecuteCode.code)
}
inline ::std::string* ExecuteCode::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    code_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.ExecuteCode.code)
  return code_;
}
inline ::std::string* ExecuteCode::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ExecuteCode::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.bosen.task.ExecuteCode.code)
}

// required int32 result_type = 2;
inline bool ExecuteCode::has_result_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecuteCode::set_has_result_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecuteCode::clear_has_result_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecuteCode::clear_result_type() {
  result_type_ = 0;
  clear_has_result_type();
}
inline ::google::protobuf::int32 ExecuteCode::result_type() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.ExecuteCode.result_type)
  return result_type_;
}
inline void ExecuteCode::set_result_type(::google::protobuf::int32 value) {
  set_has_result_type();
  result_type_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.ExecuteCode.result_type)
}

// -------------------------------------------------------------------

// TableDep

// required int32 table_id = 1;
inline bool TableDep::has_table_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableDep::set_has_table_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableDep::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableDep::clear_table_id() {
  table_id_ = 0;
  clear_has_table_id();
}
inline ::google::protobuf::int32 TableDep::table_id() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.TableDep.table_id)
  return table_id_;
}
inline void TableDep::set_table_id(::google::protobuf::int32 value) {
  set_has_table_id();
  table_id_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.TableDep.table_id)
}

// required .orion.bosen.task.TableDepType dep_type = 2;
inline bool TableDep::has_dep_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableDep::set_has_dep_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableDep::clear_has_dep_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableDep::clear_dep_type() {
  dep_type_ = 1;
  clear_has_dep_type();
}
inline ::orion::bosen::task::TableDepType TableDep::dep_type() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.TableDep.dep_type)
  return static_cast< ::orion::bosen::task::TableDepType >(dep_type_);
}
inline void TableDep::set_dep_type(::orion::bosen::task::TableDepType value) {
  assert(::orion::bosen::task::TableDepType_IsValid(value));
  set_has_dep_type();
  dep_type_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.TableDep.dep_type)
}

// required .orion.bosen.task.ReadWrite read_write = 3;
inline bool TableDep::has_read_write() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableDep::set_has_read_write() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableDep::clear_has_read_write() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableDep::clear_read_write() {
  read_write_ = 1;
  clear_has_read_write();
}
inline ::orion::bosen::task::ReadWrite TableDep::read_write() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.TableDep.read_write)
  return static_cast< ::orion::bosen::task::ReadWrite >(read_write_);
}
inline void TableDep::set_read_write(::orion::bosen::task::ReadWrite value) {
  assert(::orion::bosen::task::ReadWrite_IsValid(value));
  set_has_read_write();
  read_write_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.TableDep.read_write)
}

// optional string function_compute_dep = 4;
inline bool TableDep::has_function_compute_dep() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TableDep::set_has_function_compute_dep() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TableDep::clear_has_function_compute_dep() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TableDep::clear_function_compute_dep() {
  if (function_compute_dep_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_compute_dep_->clear();
  }
  clear_has_function_compute_dep();
}
inline const ::std::string& TableDep::function_compute_dep() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.TableDep.function_compute_dep)
  return *function_compute_dep_;
}
inline void TableDep::set_function_compute_dep(const ::std::string& value) {
  set_has_function_compute_dep();
  if (function_compute_dep_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_compute_dep_ = new ::std::string;
  }
  function_compute_dep_->assign(value);
  // @@protoc_insertion_point(field_set:orion.bosen.task.TableDep.function_compute_dep)
}
inline void TableDep::set_function_compute_dep(const char* value) {
  set_has_function_compute_dep();
  if (function_compute_dep_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_compute_dep_ = new ::std::string;
  }
  function_compute_dep_->assign(value);
  // @@protoc_insertion_point(field_set_char:orion.bosen.task.TableDep.function_compute_dep)
}
inline void TableDep::set_function_compute_dep(const char* value, size_t size) {
  set_has_function_compute_dep();
  if (function_compute_dep_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_compute_dep_ = new ::std::string;
  }
  function_compute_dep_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:orion.bosen.task.TableDep.function_compute_dep)
}
inline ::std::string* TableDep::mutable_function_compute_dep() {
  set_has_function_compute_dep();
  if (function_compute_dep_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_compute_dep_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.TableDep.function_compute_dep)
  return function_compute_dep_;
}
inline ::std::string* TableDep::release_function_compute_dep() {
  clear_has_function_compute_dep();
  if (function_compute_dep_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = function_compute_dep_;
    function_compute_dep_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TableDep::set_allocated_function_compute_dep(::std::string* function_compute_dep) {
  if (function_compute_dep_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete function_compute_dep_;
  }
  if (function_compute_dep) {
    set_has_function_compute_dep();
    function_compute_dep_ = function_compute_dep;
  } else {
    clear_has_function_compute_dep();
    function_compute_dep_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.bosen.task.TableDep.function_compute_dep)
}

// -------------------------------------------------------------------

// ConcreteBaseTable

// required int32 table_id = 1;
inline bool ConcreteBaseTable::has_table_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConcreteBaseTable::set_has_table_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConcreteBaseTable::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConcreteBaseTable::clear_table_id() {
  table_id_ = 0;
  clear_has_table_id();
}
inline ::google::protobuf::int32 ConcreteBaseTable::table_id() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.ConcreteBaseTable.table_id)
  return table_id_;
}
inline void ConcreteBaseTable::set_table_id(::google::protobuf::int32 value) {
  set_has_table_id();
  table_id_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.ConcreteBaseTable.table_id)
}

// required .orion.bosen.task.PartitionScheme partition_scheme = 2;
inline bool ConcreteBaseTable::has_partition_scheme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConcreteBaseTable::set_has_partition_scheme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConcreteBaseTable::clear_has_partition_scheme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConcreteBaseTable::clear_partition_scheme() {
  partition_scheme_ = 1;
  clear_has_partition_scheme();
}
inline ::orion::bosen::task::PartitionScheme ConcreteBaseTable::partition_scheme() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.ConcreteBaseTable.partition_scheme)
  return static_cast< ::orion::bosen::task::PartitionScheme >(partition_scheme_);
}
inline void ConcreteBaseTable::set_partition_scheme(::orion::bosen::task::PartitionScheme value) {
  assert(::orion::bosen::task::PartitionScheme_IsValid(value));
  set_has_partition_scheme();
  partition_scheme_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.ConcreteBaseTable.partition_scheme)
}

// optional uint64 partition_size = 3;
inline bool ConcreteBaseTable::has_partition_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConcreteBaseTable::set_has_partition_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConcreteBaseTable::clear_has_partition_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConcreteBaseTable::clear_partition_size() {
  partition_size_ = GOOGLE_ULONGLONG(0);
  clear_has_partition_size();
}
inline ::google::protobuf::uint64 ConcreteBaseTable::partition_size() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.ConcreteBaseTable.partition_size)
  return partition_size_;
}
inline void ConcreteBaseTable::set_partition_size(::google::protobuf::uint64 value) {
  set_has_partition_size();
  partition_size_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.ConcreteBaseTable.partition_size)
}

// -------------------------------------------------------------------

// VirtualBaseTable

// required uint64 size = 1;
inline bool VirtualBaseTable::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VirtualBaseTable::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VirtualBaseTable::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VirtualBaseTable::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 VirtualBaseTable::size() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.VirtualBaseTable.size)
  return size_;
}
inline void VirtualBaseTable::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.VirtualBaseTable.size)
}

// -------------------------------------------------------------------

// CallFunc

// required string function_name = 1;
inline bool CallFunc::has_function_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CallFunc::set_has_function_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CallFunc::clear_has_function_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CallFunc::clear_function_name() {
  if (function_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_name_->clear();
  }
  clear_has_function_name();
}
inline const ::std::string& CallFunc::function_name() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CallFunc.function_name)
  return *function_name_;
}
inline void CallFunc::set_function_name(const ::std::string& value) {
  set_has_function_name();
  if (function_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_name_ = new ::std::string;
  }
  function_name_->assign(value);
  // @@protoc_insertion_point(field_set:orion.bosen.task.CallFunc.function_name)
}
inline void CallFunc::set_function_name(const char* value) {
  set_has_function_name();
  if (function_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_name_ = new ::std::string;
  }
  function_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:orion.bosen.task.CallFunc.function_name)
}
inline void CallFunc::set_function_name(const char* value, size_t size) {
  set_has_function_name();
  if (function_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_name_ = new ::std::string;
  }
  function_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:orion.bosen.task.CallFunc.function_name)
}
inline ::std::string* CallFunc::mutable_function_name() {
  set_has_function_name();
  if (function_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.CallFunc.function_name)
  return function_name_;
}
inline ::std::string* CallFunc::release_function_name() {
  clear_has_function_name();
  if (function_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = function_name_;
    function_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CallFunc::set_allocated_function_name(::std::string* function_name) {
  if (function_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete function_name_;
  }
  if (function_name) {
    set_has_function_name();
    function_name_ = function_name;
  } else {
    clear_has_function_name();
    function_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.bosen.task.CallFunc.function_name)
}

// required .orion.bosen.task.BaseTableType base_table_type = 2;
inline bool CallFunc::has_base_table_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CallFunc::set_has_base_table_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CallFunc::clear_has_base_table_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CallFunc::clear_base_table_type() {
  base_table_type_ = 1;
  clear_has_base_table_type();
}
inline ::orion::bosen::task::BaseTableType CallFunc::base_table_type() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CallFunc.base_table_type)
  return static_cast< ::orion::bosen::task::BaseTableType >(base_table_type_);
}
inline void CallFunc::set_base_table_type(::orion::bosen::task::BaseTableType value) {
  assert(::orion::bosen::task::BaseTableType_IsValid(value));
  set_has_base_table_type();
  base_table_type_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CallFunc.base_table_type)
}

// optional .orion.bosen.task.VirtualBaseTable virtual_base_table = 3;
inline bool CallFunc::has_virtual_base_table() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CallFunc::set_has_virtual_base_table() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CallFunc::clear_has_virtual_base_table() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CallFunc::clear_virtual_base_table() {
  if (virtual_base_table_ != NULL) virtual_base_table_->::orion::bosen::task::VirtualBaseTable::Clear();
  clear_has_virtual_base_table();
}
inline const ::orion::bosen::task::VirtualBaseTable& CallFunc::virtual_base_table() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CallFunc.virtual_base_table)
  return virtual_base_table_ != NULL ? *virtual_base_table_ : *default_instance_->virtual_base_table_;
}
inline ::orion::bosen::task::VirtualBaseTable* CallFunc::mutable_virtual_base_table() {
  set_has_virtual_base_table();
  if (virtual_base_table_ == NULL) virtual_base_table_ = new ::orion::bosen::task::VirtualBaseTable;
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.CallFunc.virtual_base_table)
  return virtual_base_table_;
}
inline ::orion::bosen::task::VirtualBaseTable* CallFunc::release_virtual_base_table() {
  clear_has_virtual_base_table();
  ::orion::bosen::task::VirtualBaseTable* temp = virtual_base_table_;
  virtual_base_table_ = NULL;
  return temp;
}
inline void CallFunc::set_allocated_virtual_base_table(::orion::bosen::task::VirtualBaseTable* virtual_base_table) {
  delete virtual_base_table_;
  virtual_base_table_ = virtual_base_table;
  if (virtual_base_table) {
    set_has_virtual_base_table();
  } else {
    clear_has_virtual_base_table();
  }
  // @@protoc_insertion_point(field_set_allocated:orion.bosen.task.CallFunc.virtual_base_table)
}

// optional .orion.bosen.task.ConcreteBaseTable concrete_base_table = 4;
inline bool CallFunc::has_concrete_base_table() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CallFunc::set_has_concrete_base_table() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CallFunc::clear_has_concrete_base_table() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CallFunc::clear_concrete_base_table() {
  if (concrete_base_table_ != NULL) concrete_base_table_->::orion::bosen::task::ConcreteBaseTable::Clear();
  clear_has_concrete_base_table();
}
inline const ::orion::bosen::task::ConcreteBaseTable& CallFunc::concrete_base_table() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CallFunc.concrete_base_table)
  return concrete_base_table_ != NULL ? *concrete_base_table_ : *default_instance_->concrete_base_table_;
}
inline ::orion::bosen::task::ConcreteBaseTable* CallFunc::mutable_concrete_base_table() {
  set_has_concrete_base_table();
  if (concrete_base_table_ == NULL) concrete_base_table_ = new ::orion::bosen::task::ConcreteBaseTable;
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.CallFunc.concrete_base_table)
  return concrete_base_table_;
}
inline ::orion::bosen::task::ConcreteBaseTable* CallFunc::release_concrete_base_table() {
  clear_has_concrete_base_table();
  ::orion::bosen::task::ConcreteBaseTable* temp = concrete_base_table_;
  concrete_base_table_ = NULL;
  return temp;
}
inline void CallFunc::set_allocated_concrete_base_table(::orion::bosen::task::ConcreteBaseTable* concrete_base_table) {
  delete concrete_base_table_;
  concrete_base_table_ = concrete_base_table;
  if (concrete_base_table) {
    set_has_concrete_base_table();
  } else {
    clear_has_concrete_base_table();
  }
  // @@protoc_insertion_point(field_set_allocated:orion.bosen.task.CallFunc.concrete_base_table)
}

// repeated .orion.bosen.task.TableDep deps = 5;
inline int CallFunc::deps_size() const {
  return deps_.size();
}
inline void CallFunc::clear_deps() {
  deps_.Clear();
}
inline const ::orion::bosen::task::TableDep& CallFunc::deps(int index) const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CallFunc.deps)
  return deps_.Get(index);
}
inline ::orion::bosen::task::TableDep* CallFunc::mutable_deps(int index) {
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.CallFunc.deps)
  return deps_.Mutable(index);
}
inline ::orion::bosen::task::TableDep* CallFunc::add_deps() {
  // @@protoc_insertion_point(field_add:orion.bosen.task.CallFunc.deps)
  return deps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::orion::bosen::task::TableDep >&
CallFunc::deps() const {
  // @@protoc_insertion_point(field_list:orion.bosen.task.CallFunc.deps)
  return deps_;
}
inline ::google::protobuf::RepeatedPtrField< ::orion::bosen::task::TableDep >*
CallFunc::mutable_deps() {
  // @@protoc_insertion_point(field_mutable_list:orion.bosen.task.CallFunc.deps)
  return &deps_;
}

// required .orion.bosen.task.Repetition repetition = 6;
inline bool CallFunc::has_repetition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CallFunc::set_has_repetition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CallFunc::clear_has_repetition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CallFunc::clear_repetition() {
  repetition_ = 1;
  clear_has_repetition();
}
inline ::orion::bosen::task::Repetition CallFunc::repetition() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CallFunc.repetition)
  return static_cast< ::orion::bosen::task::Repetition >(repetition_);
}
inline void CallFunc::set_repetition(::orion::bosen::task::Repetition value) {
  assert(::orion::bosen::task::Repetition_IsValid(value));
  set_has_repetition();
  repetition_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CallFunc.repetition)
}

// required uint64 num_iterations = 7;
inline bool CallFunc::has_num_iterations() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CallFunc::set_has_num_iterations() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CallFunc::clear_has_num_iterations() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CallFunc::clear_num_iterations() {
  num_iterations_ = GOOGLE_ULONGLONG(0);
  clear_has_num_iterations();
}
inline ::google::protobuf::uint64 CallFunc::num_iterations() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CallFunc.num_iterations)
  return num_iterations_;
}
inline void CallFunc::set_num_iterations(::google::protobuf::uint64 value) {
  set_has_num_iterations();
  num_iterations_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CallFunc.num_iterations)
}

// required int32 result_type = 8;
inline bool CallFunc::has_result_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CallFunc::set_has_result_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CallFunc::clear_has_result_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CallFunc::clear_result_type() {
  result_type_ = 0;
  clear_has_result_type();
}
inline ::google::protobuf::int32 CallFunc::result_type() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CallFunc.result_type)
  return result_type_;
}
inline void CallFunc::set_result_type(::google::protobuf::int32 value) {
  set_has_result_type();
  result_type_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CallFunc.result_type)
}

// -------------------------------------------------------------------

// CreateDistArray

// required int32 id = 1;
inline bool CreateDistArray::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateDistArray::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateDistArray::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateDistArray::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 CreateDistArray::id() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.id)
  return id_;
}
inline void CreateDistArray::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.id)
}

// required .orion.bosen.task.DistArrayParentType parent_type = 2;
inline bool CreateDistArray::has_parent_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateDistArray::set_has_parent_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateDistArray::clear_has_parent_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateDistArray::clear_parent_type() {
  parent_type_ = 1;
  clear_has_parent_type();
}
inline ::orion::bosen::task::DistArrayParentType CreateDistArray::parent_type() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.parent_type)
  return static_cast< ::orion::bosen::task::DistArrayParentType >(parent_type_);
}
inline void CreateDistArray::set_parent_type(::orion::bosen::task::DistArrayParentType value) {
  assert(::orion::bosen::task::DistArrayParentType_IsValid(value));
  set_has_parent_type();
  parent_type_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.parent_type)
}

// required bool flatten_results = 3;
inline bool CreateDistArray::has_flatten_results() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateDistArray::set_has_flatten_results() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateDistArray::clear_has_flatten_results() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateDistArray::clear_flatten_results() {
  flatten_results_ = false;
  clear_has_flatten_results();
}
inline bool CreateDistArray::flatten_results() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.flatten_results)
  return flatten_results_;
}
inline void CreateDistArray::set_flatten_results(bool value) {
  set_has_flatten_results();
  flatten_results_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.flatten_results)
}

// required bool value_only = 4;
inline bool CreateDistArray::has_value_only() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateDistArray::set_has_value_only() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateDistArray::clear_has_value_only() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateDistArray::clear_value_only() {
  value_only_ = false;
  clear_has_value_only();
}
inline bool CreateDistArray::value_only() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.value_only)
  return value_only_;
}
inline void CreateDistArray::set_value_only(bool value) {
  set_has_value_only();
  value_only_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.value_only)
}

// required bool parse = 5;
inline bool CreateDistArray::has_parse() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateDistArray::set_has_parse() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateDistArray::clear_has_parse() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateDistArray::clear_parse() {
  parse_ = false;
  clear_has_parse();
}
inline bool CreateDistArray::parse() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.parse)
  return parse_;
}
inline void CreateDistArray::set_parse(bool value) {
  set_has_parse();
  parse_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.parse)
}

// required uint64 num_dims = 6;
inline bool CreateDistArray::has_num_dims() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreateDistArray::set_has_num_dims() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreateDistArray::clear_has_num_dims() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreateDistArray::clear_num_dims() {
  num_dims_ = GOOGLE_ULONGLONG(0);
  clear_has_num_dims();
}
inline ::google::protobuf::uint64 CreateDistArray::num_dims() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.num_dims)
  return num_dims_;
}
inline void CreateDistArray::set_num_dims(::google::protobuf::uint64 value) {
  set_has_num_dims();
  num_dims_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.num_dims)
}

// required int32 value_type = 7;
inline bool CreateDistArray::has_value_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreateDistArray::set_has_value_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreateDistArray::clear_has_value_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreateDistArray::clear_value_type() {
  value_type_ = 0;
  clear_has_value_type();
}
inline ::google::protobuf::int32 CreateDistArray::value_type() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.value_type)
  return value_type_;
}
inline void CreateDistArray::set_value_type(::google::protobuf::int32 value) {
  set_has_value_type();
  value_type_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.value_type)
}

// optional string file_path = 8;
inline bool CreateDistArray::has_file_path() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CreateDistArray::set_has_file_path() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CreateDistArray::clear_has_file_path() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CreateDistArray::clear_file_path() {
  if (file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_path_->clear();
  }
  clear_has_file_path();
}
inline const ::std::string& CreateDistArray::file_path() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.file_path)
  return *file_path_;
}
inline void CreateDistArray::set_file_path(const ::std::string& value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.file_path)
}
inline void CreateDistArray::set_file_path(const char* value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:orion.bosen.task.CreateDistArray.file_path)
}
inline void CreateDistArray::set_file_path(const char* value, size_t size) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:orion.bosen.task.CreateDistArray.file_path)
}
inline ::std::string* CreateDistArray::mutable_file_path() {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.CreateDistArray.file_path)
  return file_path_;
}
inline ::std::string* CreateDistArray::release_file_path() {
  clear_has_file_path();
  if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_path_;
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateDistArray::set_allocated_file_path(::std::string* file_path) {
  if (file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_path_;
  }
  if (file_path) {
    set_has_file_path();
    file_path_ = file_path;
  } else {
    clear_has_file_path();
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.bosen.task.CreateDistArray.file_path)
}

// optional int32 parent_id = 9;
inline bool CreateDistArray::has_parent_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CreateDistArray::set_has_parent_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CreateDistArray::clear_has_parent_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CreateDistArray::clear_parent_id() {
  parent_id_ = 0;
  clear_has_parent_id();
}
inline ::google::protobuf::int32 CreateDistArray::parent_id() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.parent_id)
  return parent_id_;
}
inline void CreateDistArray::set_parent_id(::google::protobuf::int32 value) {
  set_has_parent_id();
  parent_id_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.parent_id)
}

// optional .orion.bosen.task.DistArrayInitType init_type = 10;
inline bool CreateDistArray::has_init_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CreateDistArray::set_has_init_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CreateDistArray::clear_has_init_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CreateDistArray::clear_init_type() {
  init_type_ = 1;
  clear_has_init_type();
}
inline ::orion::bosen::task::DistArrayInitType CreateDistArray::init_type() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.init_type)
  return static_cast< ::orion::bosen::task::DistArrayInitType >(init_type_);
}
inline void CreateDistArray::set_init_type(::orion::bosen::task::DistArrayInitType value) {
  assert(::orion::bosen::task::DistArrayInitType_IsValid(value));
  set_has_init_type();
  init_type_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.init_type)
}

// optional int32 parser_func_module = 11;
inline bool CreateDistArray::has_parser_func_module() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CreateDistArray::set_has_parser_func_module() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CreateDistArray::clear_has_parser_func_module() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CreateDistArray::clear_parser_func_module() {
  parser_func_module_ = 0;
  clear_has_parser_func_module();
}
inline ::google::protobuf::int32 CreateDistArray::parser_func_module() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.parser_func_module)
  return parser_func_module_;
}
inline void CreateDistArray::set_parser_func_module(::google::protobuf::int32 value) {
  set_has_parser_func_module();
  parser_func_module_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.parser_func_module)
}

// optional string parser_func_name = 12;
inline bool CreateDistArray::has_parser_func_name() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CreateDistArray::set_has_parser_func_name() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CreateDistArray::clear_has_parser_func_name() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CreateDistArray::clear_parser_func_name() {
  if (parser_func_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parser_func_name_->clear();
  }
  clear_has_parser_func_name();
}
inline const ::std::string& CreateDistArray::parser_func_name() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.parser_func_name)
  return *parser_func_name_;
}
inline void CreateDistArray::set_parser_func_name(const ::std::string& value) {
  set_has_parser_func_name();
  if (parser_func_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parser_func_name_ = new ::std::string;
  }
  parser_func_name_->assign(value);
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.parser_func_name)
}
inline void CreateDistArray::set_parser_func_name(const char* value) {
  set_has_parser_func_name();
  if (parser_func_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parser_func_name_ = new ::std::string;
  }
  parser_func_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:orion.bosen.task.CreateDistArray.parser_func_name)
}
inline void CreateDistArray::set_parser_func_name(const char* value, size_t size) {
  set_has_parser_func_name();
  if (parser_func_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parser_func_name_ = new ::std::string;
  }
  parser_func_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:orion.bosen.task.CreateDistArray.parser_func_name)
}
inline ::std::string* CreateDistArray::mutable_parser_func_name() {
  set_has_parser_func_name();
  if (parser_func_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    parser_func_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.CreateDistArray.parser_func_name)
  return parser_func_name_;
}
inline ::std::string* CreateDistArray::release_parser_func_name() {
  clear_has_parser_func_name();
  if (parser_func_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = parser_func_name_;
    parser_func_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateDistArray::set_allocated_parser_func_name(::std::string* parser_func_name) {
  if (parser_func_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete parser_func_name_;
  }
  if (parser_func_name) {
    set_has_parser_func_name();
    parser_func_name_ = parser_func_name;
  } else {
    clear_has_parser_func_name();
    parser_func_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.bosen.task.CreateDistArray.parser_func_name)
}

// -------------------------------------------------------------------

// EvalExpr

// required bytes serialized_expr = 1;
inline bool EvalExpr::has_serialized_expr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EvalExpr::set_has_serialized_expr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EvalExpr::clear_has_serialized_expr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EvalExpr::clear_serialized_expr() {
  if (serialized_expr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialized_expr_->clear();
  }
  clear_has_serialized_expr();
}
inline const ::std::string& EvalExpr::serialized_expr() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.EvalExpr.serialized_expr)
  return *serialized_expr_;
}
inline void EvalExpr::set_serialized_expr(const ::std::string& value) {
  set_has_serialized_expr();
  if (serialized_expr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialized_expr_ = new ::std::string;
  }
  serialized_expr_->assign(value);
  // @@protoc_insertion_point(field_set:orion.bosen.task.EvalExpr.serialized_expr)
}
inline void EvalExpr::set_serialized_expr(const char* value) {
  set_has_serialized_expr();
  if (serialized_expr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialized_expr_ = new ::std::string;
  }
  serialized_expr_->assign(value);
  // @@protoc_insertion_point(field_set_char:orion.bosen.task.EvalExpr.serialized_expr)
}
inline void EvalExpr::set_serialized_expr(const void* value, size_t size) {
  set_has_serialized_expr();
  if (serialized_expr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialized_expr_ = new ::std::string;
  }
  serialized_expr_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:orion.bosen.task.EvalExpr.serialized_expr)
}
inline ::std::string* EvalExpr::mutable_serialized_expr() {
  set_has_serialized_expr();
  if (serialized_expr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialized_expr_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.EvalExpr.serialized_expr)
  return serialized_expr_;
}
inline ::std::string* EvalExpr::release_serialized_expr() {
  clear_has_serialized_expr();
  if (serialized_expr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serialized_expr_;
    serialized_expr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EvalExpr::set_allocated_serialized_expr(::std::string* serialized_expr) {
  if (serialized_expr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serialized_expr_;
  }
  if (serialized_expr) {
    set_has_serialized_expr();
    serialized_expr_ = serialized_expr;
  } else {
    clear_has_serialized_expr();
    serialized_expr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.bosen.task.EvalExpr.serialized_expr)
}

// required int32 result_type = 2;
inline bool EvalExpr::has_result_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EvalExpr::set_has_result_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EvalExpr::clear_has_result_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EvalExpr::clear_result_type() {
  result_type_ = 0;
  clear_has_result_type();
}
inline ::google::protobuf::int32 EvalExpr::result_type() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.EvalExpr.result_type)
  return result_type_;
}
inline void EvalExpr::set_result_type(::google::protobuf::int32 value) {
  set_has_result_type();
  result_type_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.EvalExpr.result_type)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace task
}  // namespace bosen
}  // namespace orion

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::orion::bosen::task::TableDepType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::orion::bosen::task::TableDepType>() {
  return ::orion::bosen::task::TableDepType_descriptor();
}
template <> struct is_proto_enum< ::orion::bosen::task::ReadWrite> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::orion::bosen::task::ReadWrite>() {
  return ::orion::bosen::task::ReadWrite_descriptor();
}
template <> struct is_proto_enum< ::orion::bosen::task::Repetition> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::orion::bosen::task::Repetition>() {
  return ::orion::bosen::task::Repetition_descriptor();
}
template <> struct is_proto_enum< ::orion::bosen::task::PartitionScheme> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::orion::bosen::task::PartitionScheme>() {
  return ::orion::bosen::task::PartitionScheme_descriptor();
}
template <> struct is_proto_enum< ::orion::bosen::task::BaseTableType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::orion::bosen::task::BaseTableType>() {
  return ::orion::bosen::task::BaseTableType_descriptor();
}
template <> struct is_proto_enum< ::orion::bosen::task::DistArrayParentType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::orion::bosen::task::DistArrayParentType>() {
  return ::orion::bosen::task::DistArrayParentType_descriptor();
}
template <> struct is_proto_enum< ::orion::bosen::task::DistArrayInitType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::orion::bosen::task::DistArrayInitType>() {
  return ::orion::bosen::task::DistArrayInitType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_task_2eproto__INCLUDED
