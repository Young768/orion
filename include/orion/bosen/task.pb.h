// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: task.proto

#ifndef PROTOBUF_task_2eproto__INCLUDED
#define PROTOBUF_task_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace orion {
namespace bosen {
namespace task {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_task_2eproto();
void protobuf_AssignDesc_task_2eproto();
void protobuf_ShutdownFile_task_2eproto();

class TableDep;
class ConcreteBaseTable;
class VirtualBaseTable;
class CreateDistArray;
class EvalExpr;
class DefineVar;
class SpaceTimeRepartitionDistArray;
class ExecForLoop;

enum TableDepType {
  PIPELINED = 1,
  RANDOM_ACCESS = 2
};
bool TableDepType_IsValid(int value);
const TableDepType TableDepType_MIN = PIPELINED;
const TableDepType TableDepType_MAX = RANDOM_ACCESS;
const int TableDepType_ARRAYSIZE = TableDepType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TableDepType_descriptor();
inline const ::std::string& TableDepType_Name(TableDepType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TableDepType_descriptor(), value);
}
inline bool TableDepType_Parse(
    const ::std::string& name, TableDepType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TableDepType>(
    TableDepType_descriptor(), name, value);
}
enum ReadWrite {
  READ_ONLY = 1,
  WRITE_ONLY = 2,
  READ_WRITE = 3
};
bool ReadWrite_IsValid(int value);
const ReadWrite ReadWrite_MIN = READ_ONLY;
const ReadWrite ReadWrite_MAX = READ_WRITE;
const int ReadWrite_ARRAYSIZE = ReadWrite_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReadWrite_descriptor();
inline const ::std::string& ReadWrite_Name(ReadWrite value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReadWrite_descriptor(), value);
}
inline bool ReadWrite_Parse(
    const ::std::string& name, ReadWrite* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReadWrite>(
    ReadWrite_descriptor(), name, value);
}
enum Repetition {
  ONE_PARTITION = 1,
  ALL_LOCAL_PARTITIONS = 2,
  ALL_PARTITIONS = 3
};
bool Repetition_IsValid(int value);
const Repetition Repetition_MIN = ONE_PARTITION;
const Repetition Repetition_MAX = ALL_PARTITIONS;
const int Repetition_ARRAYSIZE = Repetition_MAX + 1;

const ::google::protobuf::EnumDescriptor* Repetition_descriptor();
inline const ::std::string& Repetition_Name(Repetition value) {
  return ::google::protobuf::internal::NameOfEnum(
    Repetition_descriptor(), value);
}
inline bool Repetition_Parse(
    const ::std::string& name, Repetition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Repetition>(
    Repetition_descriptor(), name, value);
}
enum PartitionScheme {
  STATIC = 1,
  DYNAMIC = 2,
  RANDOM = 3
};
bool PartitionScheme_IsValid(int value);
const PartitionScheme PartitionScheme_MIN = STATIC;
const PartitionScheme PartitionScheme_MAX = RANDOM;
const int PartitionScheme_ARRAYSIZE = PartitionScheme_MAX + 1;

const ::google::protobuf::EnumDescriptor* PartitionScheme_descriptor();
inline const ::std::string& PartitionScheme_Name(PartitionScheme value) {
  return ::google::protobuf::internal::NameOfEnum(
    PartitionScheme_descriptor(), value);
}
inline bool PartitionScheme_Parse(
    const ::std::string& name, PartitionScheme* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PartitionScheme>(
    PartitionScheme_descriptor(), name, value);
}
enum BaseTableType {
  VIRTUAL = 1,
  CONCRETE = 2
};
bool BaseTableType_IsValid(int value);
const BaseTableType BaseTableType_MIN = VIRTUAL;
const BaseTableType BaseTableType_MAX = CONCRETE;
const int BaseTableType_ARRAYSIZE = BaseTableType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BaseTableType_descriptor();
inline const ::std::string& BaseTableType_Name(BaseTableType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BaseTableType_descriptor(), value);
}
inline bool BaseTableType_Parse(
    const ::std::string& name, BaseTableType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BaseTableType>(
    BaseTableType_descriptor(), name, value);
}
enum DistArrayParentType {
  TEXT_FILE = 1,
  DIST_ARRAY = 2,
  INIT = 3
};
bool DistArrayParentType_IsValid(int value);
const DistArrayParentType DistArrayParentType_MIN = TEXT_FILE;
const DistArrayParentType DistArrayParentType_MAX = INIT;
const int DistArrayParentType_ARRAYSIZE = DistArrayParentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DistArrayParentType_descriptor();
inline const ::std::string& DistArrayParentType_Name(DistArrayParentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DistArrayParentType_descriptor(), value);
}
inline bool DistArrayParentType_Parse(
    const ::std::string& name, DistArrayParentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DistArrayParentType>(
    DistArrayParentType_descriptor(), name, value);
}
enum DistArrayInitType {
  EMPTY = 1,
  UNIFORM_RANDOM = 2,
  NORMAL_RANDOM = 3
};
bool DistArrayInitType_IsValid(int value);
const DistArrayInitType DistArrayInitType_MIN = EMPTY;
const DistArrayInitType DistArrayInitType_MAX = NORMAL_RANDOM;
const int DistArrayInitType_ARRAYSIZE = DistArrayInitType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DistArrayInitType_descriptor();
inline const ::std::string& DistArrayInitType_Name(DistArrayInitType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DistArrayInitType_descriptor(), value);
}
inline bool DistArrayInitType_Parse(
    const ::std::string& name, DistArrayInitType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DistArrayInitType>(
    DistArrayInitType_descriptor(), name, value);
}
enum DistArrayMapType {
  NO_MAP = 1,
  MAP = 2,
  MAP_FIXED_KEYS = 3,
  MAP_VALUES = 4,
  MAP_VALUES_NEW_KEYS = 5
};
bool DistArrayMapType_IsValid(int value);
const DistArrayMapType DistArrayMapType_MIN = NO_MAP;
const DistArrayMapType DistArrayMapType_MAX = MAP_VALUES_NEW_KEYS;
const int DistArrayMapType_ARRAYSIZE = DistArrayMapType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DistArrayMapType_descriptor();
inline const ::std::string& DistArrayMapType_Name(DistArrayMapType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DistArrayMapType_descriptor(), value);
}
inline bool DistArrayMapType_Parse(
    const ::std::string& name, DistArrayMapType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DistArrayMapType>(
    DistArrayMapType_descriptor(), name, value);
}
// ===================================================================

class TableDep : public ::google::protobuf::Message {
 public:
  TableDep();
  virtual ~TableDep();

  TableDep(const TableDep& from);

  inline TableDep& operator=(const TableDep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TableDep& default_instance();

  void Swap(TableDep* other);

  // implements Message ----------------------------------------------

  TableDep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TableDep& from);
  void MergeFrom(const TableDep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 table_id = 1;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 1;
  inline ::google::protobuf::int32 table_id() const;
  inline void set_table_id(::google::protobuf::int32 value);

  // required .orion.bosen.task.TableDepType dep_type = 2;
  inline bool has_dep_type() const;
  inline void clear_dep_type();
  static const int kDepTypeFieldNumber = 2;
  inline ::orion::bosen::task::TableDepType dep_type() const;
  inline void set_dep_type(::orion::bosen::task::TableDepType value);

  // required .orion.bosen.task.ReadWrite read_write = 3;
  inline bool has_read_write() const;
  inline void clear_read_write();
  static const int kReadWriteFieldNumber = 3;
  inline ::orion::bosen::task::ReadWrite read_write() const;
  inline void set_read_write(::orion::bosen::task::ReadWrite value);

  // optional string function_compute_dep = 4;
  inline bool has_function_compute_dep() const;
  inline void clear_function_compute_dep();
  static const int kFunctionComputeDepFieldNumber = 4;
  inline const ::std::string& function_compute_dep() const;
  inline void set_function_compute_dep(const ::std::string& value);
  inline void set_function_compute_dep(const char* value);
  inline void set_function_compute_dep(const char* value, size_t size);
  inline ::std::string* mutable_function_compute_dep();
  inline ::std::string* release_function_compute_dep();
  inline void set_allocated_function_compute_dep(::std::string* function_compute_dep);

  // @@protoc_insertion_point(class_scope:orion.bosen.task.TableDep)
 private:
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_dep_type();
  inline void clear_has_dep_type();
  inline void set_has_read_write();
  inline void clear_has_read_write();
  inline void set_has_function_compute_dep();
  inline void clear_has_function_compute_dep();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 table_id_;
  int dep_type_;
  ::std::string* function_compute_dep_;
  int read_write_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static TableDep* default_instance_;
};
// -------------------------------------------------------------------

class ConcreteBaseTable : public ::google::protobuf::Message {
 public:
  ConcreteBaseTable();
  virtual ~ConcreteBaseTable();

  ConcreteBaseTable(const ConcreteBaseTable& from);

  inline ConcreteBaseTable& operator=(const ConcreteBaseTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConcreteBaseTable& default_instance();

  void Swap(ConcreteBaseTable* other);

  // implements Message ----------------------------------------------

  ConcreteBaseTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConcreteBaseTable& from);
  void MergeFrom(const ConcreteBaseTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 table_id = 1;
  inline bool has_table_id() const;
  inline void clear_table_id();
  static const int kTableIdFieldNumber = 1;
  inline ::google::protobuf::int32 table_id() const;
  inline void set_table_id(::google::protobuf::int32 value);

  // required .orion.bosen.task.PartitionScheme partition_scheme = 2;
  inline bool has_partition_scheme() const;
  inline void clear_partition_scheme();
  static const int kPartitionSchemeFieldNumber = 2;
  inline ::orion::bosen::task::PartitionScheme partition_scheme() const;
  inline void set_partition_scheme(::orion::bosen::task::PartitionScheme value);

  // optional uint64 partition_size = 3;
  inline bool has_partition_size() const;
  inline void clear_partition_size();
  static const int kPartitionSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 partition_size() const;
  inline void set_partition_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:orion.bosen.task.ConcreteBaseTable)
 private:
  inline void set_has_table_id();
  inline void clear_has_table_id();
  inline void set_has_partition_scheme();
  inline void clear_has_partition_scheme();
  inline void set_has_partition_size();
  inline void clear_has_partition_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 table_id_;
  int partition_scheme_;
  ::google::protobuf::uint64 partition_size_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static ConcreteBaseTable* default_instance_;
};
// -------------------------------------------------------------------

class VirtualBaseTable : public ::google::protobuf::Message {
 public:
  VirtualBaseTable();
  virtual ~VirtualBaseTable();

  VirtualBaseTable(const VirtualBaseTable& from);

  inline VirtualBaseTable& operator=(const VirtualBaseTable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VirtualBaseTable& default_instance();

  void Swap(VirtualBaseTable* other);

  // implements Message ----------------------------------------------

  VirtualBaseTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VirtualBaseTable& from);
  void MergeFrom(const VirtualBaseTable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:orion.bosen.task.VirtualBaseTable)
 private:
  inline void set_has_size();
  inline void clear_has_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 size_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static VirtualBaseTable* default_instance_;
};
// -------------------------------------------------------------------

class CreateDistArray : public ::google::protobuf::Message {
 public:
  CreateDistArray();
  virtual ~CreateDistArray();

  CreateDistArray(const CreateDistArray& from);

  inline CreateDistArray& operator=(const CreateDistArray& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateDistArray& default_instance();

  void Swap(CreateDistArray* other);

  // implements Message ----------------------------------------------

  CreateDistArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateDistArray& from);
  void MergeFrom(const CreateDistArray& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required .orion.bosen.task.DistArrayParentType parent_type = 2;
  inline bool has_parent_type() const;
  inline void clear_parent_type();
  static const int kParentTypeFieldNumber = 2;
  inline ::orion::bosen::task::DistArrayParentType parent_type() const;
  inline void set_parent_type(::orion::bosen::task::DistArrayParentType value);

  // required .orion.bosen.task.DistArrayMapType map_type = 3;
  inline bool has_map_type() const;
  inline void clear_map_type();
  static const int kMapTypeFieldNumber = 3;
  inline ::orion::bosen::task::DistArrayMapType map_type() const;
  inline void set_map_type(::orion::bosen::task::DistArrayMapType value);

  // required bool flatten_results = 4;
  inline bool has_flatten_results() const;
  inline void clear_flatten_results();
  static const int kFlattenResultsFieldNumber = 4;
  inline bool flatten_results() const;
  inline void set_flatten_results(bool value);

  // required uint64 num_dims = 5;
  inline bool has_num_dims() const;
  inline void clear_num_dims();
  static const int kNumDimsFieldNumber = 5;
  inline ::google::protobuf::uint64 num_dims() const;
  inline void set_num_dims(::google::protobuf::uint64 value);

  // required int32 value_type = 6;
  inline bool has_value_type() const;
  inline void clear_value_type();
  static const int kValueTypeFieldNumber = 6;
  inline ::google::protobuf::int32 value_type() const;
  inline void set_value_type(::google::protobuf::int32 value);

  // optional string file_path = 7;
  inline bool has_file_path() const;
  inline void clear_file_path();
  static const int kFilePathFieldNumber = 7;
  inline const ::std::string& file_path() const;
  inline void set_file_path(const ::std::string& value);
  inline void set_file_path(const char* value);
  inline void set_file_path(const char* value, size_t size);
  inline ::std::string* mutable_file_path();
  inline ::std::string* release_file_path();
  inline void set_allocated_file_path(::std::string* file_path);

  // optional int32 parent_id = 8;
  inline bool has_parent_id() const;
  inline void clear_parent_id();
  static const int kParentIdFieldNumber = 8;
  inline ::google::protobuf::int32 parent_id() const;
  inline void set_parent_id(::google::protobuf::int32 value);

  // optional .orion.bosen.task.DistArrayInitType init_type = 9;
  inline bool has_init_type() const;
  inline void clear_init_type();
  static const int kInitTypeFieldNumber = 9;
  inline ::orion::bosen::task::DistArrayInitType init_type() const;
  inline void set_init_type(::orion::bosen::task::DistArrayInitType value);

  // optional int32 mapper_func_module = 10;
  inline bool has_mapper_func_module() const;
  inline void clear_mapper_func_module();
  static const int kMapperFuncModuleFieldNumber = 10;
  inline ::google::protobuf::int32 mapper_func_module() const;
  inline void set_mapper_func_module(::google::protobuf::int32 value);

  // optional string mapper_func_name = 11;
  inline bool has_mapper_func_name() const;
  inline void clear_mapper_func_name();
  static const int kMapperFuncNameFieldNumber = 11;
  inline const ::std::string& mapper_func_name() const;
  inline void set_mapper_func_name(const ::std::string& value);
  inline void set_mapper_func_name(const char* value);
  inline void set_mapper_func_name(const char* value, size_t size);
  inline ::std::string* mutable_mapper_func_name();
  inline ::std::string* release_mapper_func_name();
  inline void set_allocated_mapper_func_name(::std::string* mapper_func_name);

  // repeated int64 dims = 12;
  inline int dims_size() const;
  inline void clear_dims();
  static const int kDimsFieldNumber = 12;
  inline ::google::protobuf::int64 dims(int index) const;
  inline void set_dims(int index, ::google::protobuf::int64 value);
  inline void add_dims(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      dims() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_dims();

  // optional int32 random_init_type = 13;
  inline bool has_random_init_type() const;
  inline void clear_random_init_type();
  static const int kRandomInitTypeFieldNumber = 13;
  inline ::google::protobuf::int32 random_init_type() const;
  inline void set_random_init_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:orion.bosen.task.CreateDistArray)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_parent_type();
  inline void clear_has_parent_type();
  inline void set_has_map_type();
  inline void clear_has_map_type();
  inline void set_has_flatten_results();
  inline void clear_has_flatten_results();
  inline void set_has_num_dims();
  inline void clear_has_num_dims();
  inline void set_has_value_type();
  inline void clear_has_value_type();
  inline void set_has_file_path();
  inline void clear_has_file_path();
  inline void set_has_parent_id();
  inline void clear_has_parent_id();
  inline void set_has_init_type();
  inline void clear_has_init_type();
  inline void set_has_mapper_func_module();
  inline void clear_has_mapper_func_module();
  inline void set_has_mapper_func_name();
  inline void clear_has_mapper_func_name();
  inline void set_has_random_init_type();
  inline void clear_has_random_init_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  int parent_type_;
  int map_type_;
  bool flatten_results_;
  ::google::protobuf::uint64 num_dims_;
  ::std::string* file_path_;
  ::google::protobuf::int32 value_type_;
  ::google::protobuf::int32 parent_id_;
  int init_type_;
  ::google::protobuf::int32 mapper_func_module_;
  ::std::string* mapper_func_name_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > dims_;
  ::google::protobuf::int32 random_init_type_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static CreateDistArray* default_instance_;
};
// -------------------------------------------------------------------

class EvalExpr : public ::google::protobuf::Message {
 public:
  EvalExpr();
  virtual ~EvalExpr();

  EvalExpr(const EvalExpr& from);

  inline EvalExpr& operator=(const EvalExpr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EvalExpr& default_instance();

  void Swap(EvalExpr* other);

  // implements Message ----------------------------------------------

  EvalExpr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EvalExpr& from);
  void MergeFrom(const EvalExpr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes serialized_expr = 1;
  inline bool has_serialized_expr() const;
  inline void clear_serialized_expr();
  static const int kSerializedExprFieldNumber = 1;
  inline const ::std::string& serialized_expr() const;
  inline void set_serialized_expr(const ::std::string& value);
  inline void set_serialized_expr(const char* value);
  inline void set_serialized_expr(const void* value, size_t size);
  inline ::std::string* mutable_serialized_expr();
  inline ::std::string* release_serialized_expr();
  inline void set_allocated_serialized_expr(::std::string* serialized_expr);

  // required int32 module = 2;
  inline bool has_module() const;
  inline void clear_module();
  static const int kModuleFieldNumber = 2;
  inline ::google::protobuf::int32 module() const;
  inline void set_module(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:orion.bosen.task.EvalExpr)
 private:
  inline void set_has_serialized_expr();
  inline void clear_has_serialized_expr();
  inline void set_has_module();
  inline void clear_has_module();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* serialized_expr_;
  ::google::protobuf::int32 module_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static EvalExpr* default_instance_;
};
// -------------------------------------------------------------------

class DefineVar : public ::google::protobuf::Message {
 public:
  DefineVar();
  virtual ~DefineVar();

  DefineVar(const DefineVar& from);

  inline DefineVar& operator=(const DefineVar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DefineVar& default_instance();

  void Swap(DefineVar* other);

  // implements Message ----------------------------------------------

  DefineVar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DefineVar& from);
  void MergeFrom(const DefineVar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string var_name = 1;
  inline bool has_var_name() const;
  inline void clear_var_name();
  static const int kVarNameFieldNumber = 1;
  inline const ::std::string& var_name() const;
  inline void set_var_name(const ::std::string& value);
  inline void set_var_name(const char* value);
  inline void set_var_name(const char* value, size_t size);
  inline ::std::string* mutable_var_name();
  inline ::std::string* release_var_name();
  inline void set_allocated_var_name(::std::string* var_name);

  // required bytes var_value = 2;
  inline bool has_var_value() const;
  inline void clear_var_value();
  static const int kVarValueFieldNumber = 2;
  inline const ::std::string& var_value() const;
  inline void set_var_value(const ::std::string& value);
  inline void set_var_value(const char* value);
  inline void set_var_value(const void* value, size_t size);
  inline ::std::string* mutable_var_value();
  inline ::std::string* release_var_value();
  inline void set_allocated_var_value(::std::string* var_value);

  // @@protoc_insertion_point(class_scope:orion.bosen.task.DefineVar)
 private:
  inline void set_has_var_name();
  inline void clear_has_var_name();
  inline void set_has_var_value();
  inline void clear_has_var_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* var_name_;
  ::std::string* var_value_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static DefineVar* default_instance_;
};
// -------------------------------------------------------------------

class SpaceTimeRepartitionDistArray : public ::google::protobuf::Message {
 public:
  SpaceTimeRepartitionDistArray();
  virtual ~SpaceTimeRepartitionDistArray();

  SpaceTimeRepartitionDistArray(const SpaceTimeRepartitionDistArray& from);

  inline SpaceTimeRepartitionDistArray& operator=(const SpaceTimeRepartitionDistArray& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpaceTimeRepartitionDistArray& default_instance();

  void Swap(SpaceTimeRepartitionDistArray* other);

  // implements Message ----------------------------------------------

  SpaceTimeRepartitionDistArray* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpaceTimeRepartitionDistArray& from);
  void MergeFrom(const SpaceTimeRepartitionDistArray& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string partition_func_name = 2;
  inline bool has_partition_func_name() const;
  inline void clear_partition_func_name();
  static const int kPartitionFuncNameFieldNumber = 2;
  inline const ::std::string& partition_func_name() const;
  inline void set_partition_func_name(const ::std::string& value);
  inline void set_partition_func_name(const char* value);
  inline void set_partition_func_name(const char* value, size_t size);
  inline ::std::string* mutable_partition_func_name();
  inline ::std::string* release_partition_func_name();
  inline void set_allocated_partition_func_name(::std::string* partition_func_name);

  // @@protoc_insertion_point(class_scope:orion.bosen.task.SpaceTimeRepartitionDistArray)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_partition_func_name();
  inline void clear_has_partition_func_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* partition_func_name_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static SpaceTimeRepartitionDistArray* default_instance_;
};
// -------------------------------------------------------------------

class ExecForLoop : public ::google::protobuf::Message {
 public:
  ExecForLoop();
  virtual ~ExecForLoop();

  ExecForLoop(const ExecForLoop& from);

  inline ExecForLoop& operator=(const ExecForLoop& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExecForLoop& default_instance();

  void Swap(ExecForLoop* other);

  // implements Message ----------------------------------------------

  ExecForLoop* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ExecForLoop& from);
  void MergeFrom(const ExecForLoop& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 iteration_space_id = 1;
  inline bool has_iteration_space_id() const;
  inline void clear_iteration_space_id();
  static const int kIterationSpaceIdFieldNumber = 1;
  inline ::google::protobuf::int32 iteration_space_id() const;
  inline void set_iteration_space_id(::google::protobuf::int32 value);

  // required .orion.bosen.task.BaseTableType base_table_type = 2;
  inline bool has_base_table_type() const;
  inline void clear_base_table_type();
  static const int kBaseTableTypeFieldNumber = 2;
  inline ::orion::bosen::task::BaseTableType base_table_type() const;
  inline void set_base_table_type(::orion::bosen::task::BaseTableType value);

  // optional .orion.bosen.task.VirtualBaseTable virtual_base_table = 3;
  inline bool has_virtual_base_table() const;
  inline void clear_virtual_base_table();
  static const int kVirtualBaseTableFieldNumber = 3;
  inline const ::orion::bosen::task::VirtualBaseTable& virtual_base_table() const;
  inline ::orion::bosen::task::VirtualBaseTable* mutable_virtual_base_table();
  inline ::orion::bosen::task::VirtualBaseTable* release_virtual_base_table();
  inline void set_allocated_virtual_base_table(::orion::bosen::task::VirtualBaseTable* virtual_base_table);

  // optional .orion.bosen.task.ConcreteBaseTable concrete_base_table = 4;
  inline bool has_concrete_base_table() const;
  inline void clear_concrete_base_table();
  static const int kConcreteBaseTableFieldNumber = 4;
  inline const ::orion::bosen::task::ConcreteBaseTable& concrete_base_table() const;
  inline ::orion::bosen::task::ConcreteBaseTable* mutable_concrete_base_table();
  inline ::orion::bosen::task::ConcreteBaseTable* release_concrete_base_table();
  inline void set_allocated_concrete_base_table(::orion::bosen::task::ConcreteBaseTable* concrete_base_table);

  // repeated .orion.bosen.task.TableDep deps = 5;
  inline int deps_size() const;
  inline void clear_deps();
  static const int kDepsFieldNumber = 5;
  inline const ::orion::bosen::task::TableDep& deps(int index) const;
  inline ::orion::bosen::task::TableDep* mutable_deps(int index);
  inline ::orion::bosen::task::TableDep* add_deps();
  inline const ::google::protobuf::RepeatedPtrField< ::orion::bosen::task::TableDep >&
      deps() const;
  inline ::google::protobuf::RepeatedPtrField< ::orion::bosen::task::TableDep >*
      mutable_deps();

  // required .orion.bosen.task.Repetition repetition = 6;
  inline bool has_repetition() const;
  inline void clear_repetition();
  static const int kRepetitionFieldNumber = 6;
  inline ::orion::bosen::task::Repetition repetition() const;
  inline void set_repetition(::orion::bosen::task::Repetition value);

  // required uint64 num_iterations = 7;
  inline bool has_num_iterations() const;
  inline void clear_num_iterations();
  static const int kNumIterationsFieldNumber = 7;
  inline ::google::protobuf::uint64 num_iterations() const;
  inline void set_num_iterations(::google::protobuf::uint64 value);

  // required int32 result_type = 8;
  inline bool has_result_type() const;
  inline void clear_result_type();
  static const int kResultTypeFieldNumber = 8;
  inline ::google::protobuf::int32 result_type() const;
  inline void set_result_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:orion.bosen.task.ExecForLoop)
 private:
  inline void set_has_iteration_space_id();
  inline void clear_has_iteration_space_id();
  inline void set_has_base_table_type();
  inline void clear_has_base_table_type();
  inline void set_has_virtual_base_table();
  inline void clear_has_virtual_base_table();
  inline void set_has_concrete_base_table();
  inline void clear_has_concrete_base_table();
  inline void set_has_repetition();
  inline void clear_has_repetition();
  inline void set_has_num_iterations();
  inline void clear_has_num_iterations();
  inline void set_has_result_type();
  inline void clear_has_result_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 iteration_space_id_;
  int base_table_type_;
  ::orion::bosen::task::VirtualBaseTable* virtual_base_table_;
  ::orion::bosen::task::ConcreteBaseTable* concrete_base_table_;
  ::google::protobuf::RepeatedPtrField< ::orion::bosen::task::TableDep > deps_;
  ::google::protobuf::uint64 num_iterations_;
  int repetition_;
  ::google::protobuf::int32 result_type_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static ExecForLoop* default_instance_;
};
// ===================================================================


// ===================================================================

// TableDep

// required int32 table_id = 1;
inline bool TableDep::has_table_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TableDep::set_has_table_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TableDep::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TableDep::clear_table_id() {
  table_id_ = 0;
  clear_has_table_id();
}
inline ::google::protobuf::int32 TableDep::table_id() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.TableDep.table_id)
  return table_id_;
}
inline void TableDep::set_table_id(::google::protobuf::int32 value) {
  set_has_table_id();
  table_id_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.TableDep.table_id)
}

// required .orion.bosen.task.TableDepType dep_type = 2;
inline bool TableDep::has_dep_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TableDep::set_has_dep_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TableDep::clear_has_dep_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TableDep::clear_dep_type() {
  dep_type_ = 1;
  clear_has_dep_type();
}
inline ::orion::bosen::task::TableDepType TableDep::dep_type() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.TableDep.dep_type)
  return static_cast< ::orion::bosen::task::TableDepType >(dep_type_);
}
inline void TableDep::set_dep_type(::orion::bosen::task::TableDepType value) {
  assert(::orion::bosen::task::TableDepType_IsValid(value));
  set_has_dep_type();
  dep_type_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.TableDep.dep_type)
}

// required .orion.bosen.task.ReadWrite read_write = 3;
inline bool TableDep::has_read_write() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TableDep::set_has_read_write() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TableDep::clear_has_read_write() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TableDep::clear_read_write() {
  read_write_ = 1;
  clear_has_read_write();
}
inline ::orion::bosen::task::ReadWrite TableDep::read_write() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.TableDep.read_write)
  return static_cast< ::orion::bosen::task::ReadWrite >(read_write_);
}
inline void TableDep::set_read_write(::orion::bosen::task::ReadWrite value) {
  assert(::orion::bosen::task::ReadWrite_IsValid(value));
  set_has_read_write();
  read_write_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.TableDep.read_write)
}

// optional string function_compute_dep = 4;
inline bool TableDep::has_function_compute_dep() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TableDep::set_has_function_compute_dep() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TableDep::clear_has_function_compute_dep() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TableDep::clear_function_compute_dep() {
  if (function_compute_dep_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_compute_dep_->clear();
  }
  clear_has_function_compute_dep();
}
inline const ::std::string& TableDep::function_compute_dep() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.TableDep.function_compute_dep)
  return *function_compute_dep_;
}
inline void TableDep::set_function_compute_dep(const ::std::string& value) {
  set_has_function_compute_dep();
  if (function_compute_dep_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_compute_dep_ = new ::std::string;
  }
  function_compute_dep_->assign(value);
  // @@protoc_insertion_point(field_set:orion.bosen.task.TableDep.function_compute_dep)
}
inline void TableDep::set_function_compute_dep(const char* value) {
  set_has_function_compute_dep();
  if (function_compute_dep_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_compute_dep_ = new ::std::string;
  }
  function_compute_dep_->assign(value);
  // @@protoc_insertion_point(field_set_char:orion.bosen.task.TableDep.function_compute_dep)
}
inline void TableDep::set_function_compute_dep(const char* value, size_t size) {
  set_has_function_compute_dep();
  if (function_compute_dep_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_compute_dep_ = new ::std::string;
  }
  function_compute_dep_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:orion.bosen.task.TableDep.function_compute_dep)
}
inline ::std::string* TableDep::mutable_function_compute_dep() {
  set_has_function_compute_dep();
  if (function_compute_dep_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    function_compute_dep_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.TableDep.function_compute_dep)
  return function_compute_dep_;
}
inline ::std::string* TableDep::release_function_compute_dep() {
  clear_has_function_compute_dep();
  if (function_compute_dep_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = function_compute_dep_;
    function_compute_dep_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TableDep::set_allocated_function_compute_dep(::std::string* function_compute_dep) {
  if (function_compute_dep_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete function_compute_dep_;
  }
  if (function_compute_dep) {
    set_has_function_compute_dep();
    function_compute_dep_ = function_compute_dep;
  } else {
    clear_has_function_compute_dep();
    function_compute_dep_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.bosen.task.TableDep.function_compute_dep)
}

// -------------------------------------------------------------------

// ConcreteBaseTable

// required int32 table_id = 1;
inline bool ConcreteBaseTable::has_table_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConcreteBaseTable::set_has_table_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConcreteBaseTable::clear_has_table_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConcreteBaseTable::clear_table_id() {
  table_id_ = 0;
  clear_has_table_id();
}
inline ::google::protobuf::int32 ConcreteBaseTable::table_id() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.ConcreteBaseTable.table_id)
  return table_id_;
}
inline void ConcreteBaseTable::set_table_id(::google::protobuf::int32 value) {
  set_has_table_id();
  table_id_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.ConcreteBaseTable.table_id)
}

// required .orion.bosen.task.PartitionScheme partition_scheme = 2;
inline bool ConcreteBaseTable::has_partition_scheme() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConcreteBaseTable::set_has_partition_scheme() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConcreteBaseTable::clear_has_partition_scheme() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConcreteBaseTable::clear_partition_scheme() {
  partition_scheme_ = 1;
  clear_has_partition_scheme();
}
inline ::orion::bosen::task::PartitionScheme ConcreteBaseTable::partition_scheme() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.ConcreteBaseTable.partition_scheme)
  return static_cast< ::orion::bosen::task::PartitionScheme >(partition_scheme_);
}
inline void ConcreteBaseTable::set_partition_scheme(::orion::bosen::task::PartitionScheme value) {
  assert(::orion::bosen::task::PartitionScheme_IsValid(value));
  set_has_partition_scheme();
  partition_scheme_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.ConcreteBaseTable.partition_scheme)
}

// optional uint64 partition_size = 3;
inline bool ConcreteBaseTable::has_partition_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConcreteBaseTable::set_has_partition_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConcreteBaseTable::clear_has_partition_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConcreteBaseTable::clear_partition_size() {
  partition_size_ = GOOGLE_ULONGLONG(0);
  clear_has_partition_size();
}
inline ::google::protobuf::uint64 ConcreteBaseTable::partition_size() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.ConcreteBaseTable.partition_size)
  return partition_size_;
}
inline void ConcreteBaseTable::set_partition_size(::google::protobuf::uint64 value) {
  set_has_partition_size();
  partition_size_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.ConcreteBaseTable.partition_size)
}

// -------------------------------------------------------------------

// VirtualBaseTable

// required uint64 size = 1;
inline bool VirtualBaseTable::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VirtualBaseTable::set_has_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VirtualBaseTable::clear_has_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VirtualBaseTable::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 VirtualBaseTable::size() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.VirtualBaseTable.size)
  return size_;
}
inline void VirtualBaseTable::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.VirtualBaseTable.size)
}

// -------------------------------------------------------------------

// CreateDistArray

// required int32 id = 1;
inline bool CreateDistArray::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateDistArray::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateDistArray::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateDistArray::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 CreateDistArray::id() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.id)
  return id_;
}
inline void CreateDistArray::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.id)
}

// required .orion.bosen.task.DistArrayParentType parent_type = 2;
inline bool CreateDistArray::has_parent_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateDistArray::set_has_parent_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateDistArray::clear_has_parent_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateDistArray::clear_parent_type() {
  parent_type_ = 1;
  clear_has_parent_type();
}
inline ::orion::bosen::task::DistArrayParentType CreateDistArray::parent_type() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.parent_type)
  return static_cast< ::orion::bosen::task::DistArrayParentType >(parent_type_);
}
inline void CreateDistArray::set_parent_type(::orion::bosen::task::DistArrayParentType value) {
  assert(::orion::bosen::task::DistArrayParentType_IsValid(value));
  set_has_parent_type();
  parent_type_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.parent_type)
}

// required .orion.bosen.task.DistArrayMapType map_type = 3;
inline bool CreateDistArray::has_map_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateDistArray::set_has_map_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateDistArray::clear_has_map_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateDistArray::clear_map_type() {
  map_type_ = 1;
  clear_has_map_type();
}
inline ::orion::bosen::task::DistArrayMapType CreateDistArray::map_type() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.map_type)
  return static_cast< ::orion::bosen::task::DistArrayMapType >(map_type_);
}
inline void CreateDistArray::set_map_type(::orion::bosen::task::DistArrayMapType value) {
  assert(::orion::bosen::task::DistArrayMapType_IsValid(value));
  set_has_map_type();
  map_type_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.map_type)
}

// required bool flatten_results = 4;
inline bool CreateDistArray::has_flatten_results() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateDistArray::set_has_flatten_results() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateDistArray::clear_has_flatten_results() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateDistArray::clear_flatten_results() {
  flatten_results_ = false;
  clear_has_flatten_results();
}
inline bool CreateDistArray::flatten_results() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.flatten_results)
  return flatten_results_;
}
inline void CreateDistArray::set_flatten_results(bool value) {
  set_has_flatten_results();
  flatten_results_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.flatten_results)
}

// required uint64 num_dims = 5;
inline bool CreateDistArray::has_num_dims() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateDistArray::set_has_num_dims() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateDistArray::clear_has_num_dims() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateDistArray::clear_num_dims() {
  num_dims_ = GOOGLE_ULONGLONG(0);
  clear_has_num_dims();
}
inline ::google::protobuf::uint64 CreateDistArray::num_dims() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.num_dims)
  return num_dims_;
}
inline void CreateDistArray::set_num_dims(::google::protobuf::uint64 value) {
  set_has_num_dims();
  num_dims_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.num_dims)
}

// required int32 value_type = 6;
inline bool CreateDistArray::has_value_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreateDistArray::set_has_value_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreateDistArray::clear_has_value_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreateDistArray::clear_value_type() {
  value_type_ = 0;
  clear_has_value_type();
}
inline ::google::protobuf::int32 CreateDistArray::value_type() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.value_type)
  return value_type_;
}
inline void CreateDistArray::set_value_type(::google::protobuf::int32 value) {
  set_has_value_type();
  value_type_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.value_type)
}

// optional string file_path = 7;
inline bool CreateDistArray::has_file_path() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreateDistArray::set_has_file_path() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreateDistArray::clear_has_file_path() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreateDistArray::clear_file_path() {
  if (file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_path_->clear();
  }
  clear_has_file_path();
}
inline const ::std::string& CreateDistArray::file_path() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.file_path)
  return *file_path_;
}
inline void CreateDistArray::set_file_path(const ::std::string& value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.file_path)
}
inline void CreateDistArray::set_file_path(const char* value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
  // @@protoc_insertion_point(field_set_char:orion.bosen.task.CreateDistArray.file_path)
}
inline void CreateDistArray::set_file_path(const char* value, size_t size) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:orion.bosen.task.CreateDistArray.file_path)
}
inline ::std::string* CreateDistArray::mutable_file_path() {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    file_path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.CreateDistArray.file_path)
  return file_path_;
}
inline ::std::string* CreateDistArray::release_file_path() {
  clear_has_file_path();
  if (file_path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = file_path_;
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateDistArray::set_allocated_file_path(::std::string* file_path) {
  if (file_path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete file_path_;
  }
  if (file_path) {
    set_has_file_path();
    file_path_ = file_path;
  } else {
    clear_has_file_path();
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.bosen.task.CreateDistArray.file_path)
}

// optional int32 parent_id = 8;
inline bool CreateDistArray::has_parent_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CreateDistArray::set_has_parent_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CreateDistArray::clear_has_parent_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CreateDistArray::clear_parent_id() {
  parent_id_ = 0;
  clear_has_parent_id();
}
inline ::google::protobuf::int32 CreateDistArray::parent_id() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.parent_id)
  return parent_id_;
}
inline void CreateDistArray::set_parent_id(::google::protobuf::int32 value) {
  set_has_parent_id();
  parent_id_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.parent_id)
}

// optional .orion.bosen.task.DistArrayInitType init_type = 9;
inline bool CreateDistArray::has_init_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CreateDistArray::set_has_init_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CreateDistArray::clear_has_init_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CreateDistArray::clear_init_type() {
  init_type_ = 1;
  clear_has_init_type();
}
inline ::orion::bosen::task::DistArrayInitType CreateDistArray::init_type() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.init_type)
  return static_cast< ::orion::bosen::task::DistArrayInitType >(init_type_);
}
inline void CreateDistArray::set_init_type(::orion::bosen::task::DistArrayInitType value) {
  assert(::orion::bosen::task::DistArrayInitType_IsValid(value));
  set_has_init_type();
  init_type_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.init_type)
}

// optional int32 mapper_func_module = 10;
inline bool CreateDistArray::has_mapper_func_module() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CreateDistArray::set_has_mapper_func_module() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CreateDistArray::clear_has_mapper_func_module() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CreateDistArray::clear_mapper_func_module() {
  mapper_func_module_ = 0;
  clear_has_mapper_func_module();
}
inline ::google::protobuf::int32 CreateDistArray::mapper_func_module() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.mapper_func_module)
  return mapper_func_module_;
}
inline void CreateDistArray::set_mapper_func_module(::google::protobuf::int32 value) {
  set_has_mapper_func_module();
  mapper_func_module_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.mapper_func_module)
}

// optional string mapper_func_name = 11;
inline bool CreateDistArray::has_mapper_func_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CreateDistArray::set_has_mapper_func_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CreateDistArray::clear_has_mapper_func_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CreateDistArray::clear_mapper_func_name() {
  if (mapper_func_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapper_func_name_->clear();
  }
  clear_has_mapper_func_name();
}
inline const ::std::string& CreateDistArray::mapper_func_name() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.mapper_func_name)
  return *mapper_func_name_;
}
inline void CreateDistArray::set_mapper_func_name(const ::std::string& value) {
  set_has_mapper_func_name();
  if (mapper_func_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapper_func_name_ = new ::std::string;
  }
  mapper_func_name_->assign(value);
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.mapper_func_name)
}
inline void CreateDistArray::set_mapper_func_name(const char* value) {
  set_has_mapper_func_name();
  if (mapper_func_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapper_func_name_ = new ::std::string;
  }
  mapper_func_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:orion.bosen.task.CreateDistArray.mapper_func_name)
}
inline void CreateDistArray::set_mapper_func_name(const char* value, size_t size) {
  set_has_mapper_func_name();
  if (mapper_func_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapper_func_name_ = new ::std::string;
  }
  mapper_func_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:orion.bosen.task.CreateDistArray.mapper_func_name)
}
inline ::std::string* CreateDistArray::mutable_mapper_func_name() {
  set_has_mapper_func_name();
  if (mapper_func_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    mapper_func_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.CreateDistArray.mapper_func_name)
  return mapper_func_name_;
}
inline ::std::string* CreateDistArray::release_mapper_func_name() {
  clear_has_mapper_func_name();
  if (mapper_func_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = mapper_func_name_;
    mapper_func_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CreateDistArray::set_allocated_mapper_func_name(::std::string* mapper_func_name) {
  if (mapper_func_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete mapper_func_name_;
  }
  if (mapper_func_name) {
    set_has_mapper_func_name();
    mapper_func_name_ = mapper_func_name;
  } else {
    clear_has_mapper_func_name();
    mapper_func_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.bosen.task.CreateDistArray.mapper_func_name)
}

// repeated int64 dims = 12;
inline int CreateDistArray::dims_size() const {
  return dims_.size();
}
inline void CreateDistArray::clear_dims() {
  dims_.Clear();
}
inline ::google::protobuf::int64 CreateDistArray::dims(int index) const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.dims)
  return dims_.Get(index);
}
inline void CreateDistArray::set_dims(int index, ::google::protobuf::int64 value) {
  dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.dims)
}
inline void CreateDistArray::add_dims(::google::protobuf::int64 value) {
  dims_.Add(value);
  // @@protoc_insertion_point(field_add:orion.bosen.task.CreateDistArray.dims)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
CreateDistArray::dims() const {
  // @@protoc_insertion_point(field_list:orion.bosen.task.CreateDistArray.dims)
  return dims_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
CreateDistArray::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:orion.bosen.task.CreateDistArray.dims)
  return &dims_;
}

// optional int32 random_init_type = 13;
inline bool CreateDistArray::has_random_init_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CreateDistArray::set_has_random_init_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CreateDistArray::clear_has_random_init_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CreateDistArray::clear_random_init_type() {
  random_init_type_ = 0;
  clear_has_random_init_type();
}
inline ::google::protobuf::int32 CreateDistArray::random_init_type() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.CreateDistArray.random_init_type)
  return random_init_type_;
}
inline void CreateDistArray::set_random_init_type(::google::protobuf::int32 value) {
  set_has_random_init_type();
  random_init_type_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.CreateDistArray.random_init_type)
}

// -------------------------------------------------------------------

// EvalExpr

// required bytes serialized_expr = 1;
inline bool EvalExpr::has_serialized_expr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EvalExpr::set_has_serialized_expr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EvalExpr::clear_has_serialized_expr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EvalExpr::clear_serialized_expr() {
  if (serialized_expr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialized_expr_->clear();
  }
  clear_has_serialized_expr();
}
inline const ::std::string& EvalExpr::serialized_expr() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.EvalExpr.serialized_expr)
  return *serialized_expr_;
}
inline void EvalExpr::set_serialized_expr(const ::std::string& value) {
  set_has_serialized_expr();
  if (serialized_expr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialized_expr_ = new ::std::string;
  }
  serialized_expr_->assign(value);
  // @@protoc_insertion_point(field_set:orion.bosen.task.EvalExpr.serialized_expr)
}
inline void EvalExpr::set_serialized_expr(const char* value) {
  set_has_serialized_expr();
  if (serialized_expr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialized_expr_ = new ::std::string;
  }
  serialized_expr_->assign(value);
  // @@protoc_insertion_point(field_set_char:orion.bosen.task.EvalExpr.serialized_expr)
}
inline void EvalExpr::set_serialized_expr(const void* value, size_t size) {
  set_has_serialized_expr();
  if (serialized_expr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialized_expr_ = new ::std::string;
  }
  serialized_expr_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:orion.bosen.task.EvalExpr.serialized_expr)
}
inline ::std::string* EvalExpr::mutable_serialized_expr() {
  set_has_serialized_expr();
  if (serialized_expr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    serialized_expr_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.EvalExpr.serialized_expr)
  return serialized_expr_;
}
inline ::std::string* EvalExpr::release_serialized_expr() {
  clear_has_serialized_expr();
  if (serialized_expr_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = serialized_expr_;
    serialized_expr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void EvalExpr::set_allocated_serialized_expr(::std::string* serialized_expr) {
  if (serialized_expr_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete serialized_expr_;
  }
  if (serialized_expr) {
    set_has_serialized_expr();
    serialized_expr_ = serialized_expr;
  } else {
    clear_has_serialized_expr();
    serialized_expr_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.bosen.task.EvalExpr.serialized_expr)
}

// required int32 module = 2;
inline bool EvalExpr::has_module() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EvalExpr::set_has_module() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EvalExpr::clear_has_module() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EvalExpr::clear_module() {
  module_ = 0;
  clear_has_module();
}
inline ::google::protobuf::int32 EvalExpr::module() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.EvalExpr.module)
  return module_;
}
inline void EvalExpr::set_module(::google::protobuf::int32 value) {
  set_has_module();
  module_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.EvalExpr.module)
}

// -------------------------------------------------------------------

// DefineVar

// required string var_name = 1;
inline bool DefineVar::has_var_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DefineVar::set_has_var_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DefineVar::clear_has_var_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DefineVar::clear_var_name() {
  if (var_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    var_name_->clear();
  }
  clear_has_var_name();
}
inline const ::std::string& DefineVar::var_name() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.DefineVar.var_name)
  return *var_name_;
}
inline void DefineVar::set_var_name(const ::std::string& value) {
  set_has_var_name();
  if (var_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    var_name_ = new ::std::string;
  }
  var_name_->assign(value);
  // @@protoc_insertion_point(field_set:orion.bosen.task.DefineVar.var_name)
}
inline void DefineVar::set_var_name(const char* value) {
  set_has_var_name();
  if (var_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    var_name_ = new ::std::string;
  }
  var_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:orion.bosen.task.DefineVar.var_name)
}
inline void DefineVar::set_var_name(const char* value, size_t size) {
  set_has_var_name();
  if (var_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    var_name_ = new ::std::string;
  }
  var_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:orion.bosen.task.DefineVar.var_name)
}
inline ::std::string* DefineVar::mutable_var_name() {
  set_has_var_name();
  if (var_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    var_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.DefineVar.var_name)
  return var_name_;
}
inline ::std::string* DefineVar::release_var_name() {
  clear_has_var_name();
  if (var_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = var_name_;
    var_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DefineVar::set_allocated_var_name(::std::string* var_name) {
  if (var_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete var_name_;
  }
  if (var_name) {
    set_has_var_name();
    var_name_ = var_name;
  } else {
    clear_has_var_name();
    var_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.bosen.task.DefineVar.var_name)
}

// required bytes var_value = 2;
inline bool DefineVar::has_var_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DefineVar::set_has_var_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DefineVar::clear_has_var_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DefineVar::clear_var_value() {
  if (var_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    var_value_->clear();
  }
  clear_has_var_value();
}
inline const ::std::string& DefineVar::var_value() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.DefineVar.var_value)
  return *var_value_;
}
inline void DefineVar::set_var_value(const ::std::string& value) {
  set_has_var_value();
  if (var_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    var_value_ = new ::std::string;
  }
  var_value_->assign(value);
  // @@protoc_insertion_point(field_set:orion.bosen.task.DefineVar.var_value)
}
inline void DefineVar::set_var_value(const char* value) {
  set_has_var_value();
  if (var_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    var_value_ = new ::std::string;
  }
  var_value_->assign(value);
  // @@protoc_insertion_point(field_set_char:orion.bosen.task.DefineVar.var_value)
}
inline void DefineVar::set_var_value(const void* value, size_t size) {
  set_has_var_value();
  if (var_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    var_value_ = new ::std::string;
  }
  var_value_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:orion.bosen.task.DefineVar.var_value)
}
inline ::std::string* DefineVar::mutable_var_value() {
  set_has_var_value();
  if (var_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    var_value_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.DefineVar.var_value)
  return var_value_;
}
inline ::std::string* DefineVar::release_var_value() {
  clear_has_var_value();
  if (var_value_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = var_value_;
    var_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DefineVar::set_allocated_var_value(::std::string* var_value) {
  if (var_value_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete var_value_;
  }
  if (var_value) {
    set_has_var_value();
    var_value_ = var_value;
  } else {
    clear_has_var_value();
    var_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.bosen.task.DefineVar.var_value)
}

// -------------------------------------------------------------------

// SpaceTimeRepartitionDistArray

// required int32 id = 1;
inline bool SpaceTimeRepartitionDistArray::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpaceTimeRepartitionDistArray::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpaceTimeRepartitionDistArray::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpaceTimeRepartitionDistArray::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 SpaceTimeRepartitionDistArray::id() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.SpaceTimeRepartitionDistArray.id)
  return id_;
}
inline void SpaceTimeRepartitionDistArray::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.SpaceTimeRepartitionDistArray.id)
}

// required string partition_func_name = 2;
inline bool SpaceTimeRepartitionDistArray::has_partition_func_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpaceTimeRepartitionDistArray::set_has_partition_func_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpaceTimeRepartitionDistArray::clear_has_partition_func_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpaceTimeRepartitionDistArray::clear_partition_func_name() {
  if (partition_func_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    partition_func_name_->clear();
  }
  clear_has_partition_func_name();
}
inline const ::std::string& SpaceTimeRepartitionDistArray::partition_func_name() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.SpaceTimeRepartitionDistArray.partition_func_name)
  return *partition_func_name_;
}
inline void SpaceTimeRepartitionDistArray::set_partition_func_name(const ::std::string& value) {
  set_has_partition_func_name();
  if (partition_func_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    partition_func_name_ = new ::std::string;
  }
  partition_func_name_->assign(value);
  // @@protoc_insertion_point(field_set:orion.bosen.task.SpaceTimeRepartitionDistArray.partition_func_name)
}
inline void SpaceTimeRepartitionDistArray::set_partition_func_name(const char* value) {
  set_has_partition_func_name();
  if (partition_func_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    partition_func_name_ = new ::std::string;
  }
  partition_func_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:orion.bosen.task.SpaceTimeRepartitionDistArray.partition_func_name)
}
inline void SpaceTimeRepartitionDistArray::set_partition_func_name(const char* value, size_t size) {
  set_has_partition_func_name();
  if (partition_func_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    partition_func_name_ = new ::std::string;
  }
  partition_func_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:orion.bosen.task.SpaceTimeRepartitionDistArray.partition_func_name)
}
inline ::std::string* SpaceTimeRepartitionDistArray::mutable_partition_func_name() {
  set_has_partition_func_name();
  if (partition_func_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    partition_func_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.SpaceTimeRepartitionDistArray.partition_func_name)
  return partition_func_name_;
}
inline ::std::string* SpaceTimeRepartitionDistArray::release_partition_func_name() {
  clear_has_partition_func_name();
  if (partition_func_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = partition_func_name_;
    partition_func_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void SpaceTimeRepartitionDistArray::set_allocated_partition_func_name(::std::string* partition_func_name) {
  if (partition_func_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete partition_func_name_;
  }
  if (partition_func_name) {
    set_has_partition_func_name();
    partition_func_name_ = partition_func_name;
  } else {
    clear_has_partition_func_name();
    partition_func_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:orion.bosen.task.SpaceTimeRepartitionDistArray.partition_func_name)
}

// -------------------------------------------------------------------

// ExecForLoop

// required int32 iteration_space_id = 1;
inline bool ExecForLoop::has_iteration_space_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExecForLoop::set_has_iteration_space_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExecForLoop::clear_has_iteration_space_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExecForLoop::clear_iteration_space_id() {
  iteration_space_id_ = 0;
  clear_has_iteration_space_id();
}
inline ::google::protobuf::int32 ExecForLoop::iteration_space_id() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.ExecForLoop.iteration_space_id)
  return iteration_space_id_;
}
inline void ExecForLoop::set_iteration_space_id(::google::protobuf::int32 value) {
  set_has_iteration_space_id();
  iteration_space_id_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.ExecForLoop.iteration_space_id)
}

// required .orion.bosen.task.BaseTableType base_table_type = 2;
inline bool ExecForLoop::has_base_table_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExecForLoop::set_has_base_table_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExecForLoop::clear_has_base_table_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExecForLoop::clear_base_table_type() {
  base_table_type_ = 1;
  clear_has_base_table_type();
}
inline ::orion::bosen::task::BaseTableType ExecForLoop::base_table_type() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.ExecForLoop.base_table_type)
  return static_cast< ::orion::bosen::task::BaseTableType >(base_table_type_);
}
inline void ExecForLoop::set_base_table_type(::orion::bosen::task::BaseTableType value) {
  assert(::orion::bosen::task::BaseTableType_IsValid(value));
  set_has_base_table_type();
  base_table_type_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.ExecForLoop.base_table_type)
}

// optional .orion.bosen.task.VirtualBaseTable virtual_base_table = 3;
inline bool ExecForLoop::has_virtual_base_table() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExecForLoop::set_has_virtual_base_table() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExecForLoop::clear_has_virtual_base_table() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExecForLoop::clear_virtual_base_table() {
  if (virtual_base_table_ != NULL) virtual_base_table_->::orion::bosen::task::VirtualBaseTable::Clear();
  clear_has_virtual_base_table();
}
inline const ::orion::bosen::task::VirtualBaseTable& ExecForLoop::virtual_base_table() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.ExecForLoop.virtual_base_table)
  return virtual_base_table_ != NULL ? *virtual_base_table_ : *default_instance_->virtual_base_table_;
}
inline ::orion::bosen::task::VirtualBaseTable* ExecForLoop::mutable_virtual_base_table() {
  set_has_virtual_base_table();
  if (virtual_base_table_ == NULL) virtual_base_table_ = new ::orion::bosen::task::VirtualBaseTable;
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.ExecForLoop.virtual_base_table)
  return virtual_base_table_;
}
inline ::orion::bosen::task::VirtualBaseTable* ExecForLoop::release_virtual_base_table() {
  clear_has_virtual_base_table();
  ::orion::bosen::task::VirtualBaseTable* temp = virtual_base_table_;
  virtual_base_table_ = NULL;
  return temp;
}
inline void ExecForLoop::set_allocated_virtual_base_table(::orion::bosen::task::VirtualBaseTable* virtual_base_table) {
  delete virtual_base_table_;
  virtual_base_table_ = virtual_base_table;
  if (virtual_base_table) {
    set_has_virtual_base_table();
  } else {
    clear_has_virtual_base_table();
  }
  // @@protoc_insertion_point(field_set_allocated:orion.bosen.task.ExecForLoop.virtual_base_table)
}

// optional .orion.bosen.task.ConcreteBaseTable concrete_base_table = 4;
inline bool ExecForLoop::has_concrete_base_table() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExecForLoop::set_has_concrete_base_table() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExecForLoop::clear_has_concrete_base_table() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExecForLoop::clear_concrete_base_table() {
  if (concrete_base_table_ != NULL) concrete_base_table_->::orion::bosen::task::ConcreteBaseTable::Clear();
  clear_has_concrete_base_table();
}
inline const ::orion::bosen::task::ConcreteBaseTable& ExecForLoop::concrete_base_table() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.ExecForLoop.concrete_base_table)
  return concrete_base_table_ != NULL ? *concrete_base_table_ : *default_instance_->concrete_base_table_;
}
inline ::orion::bosen::task::ConcreteBaseTable* ExecForLoop::mutable_concrete_base_table() {
  set_has_concrete_base_table();
  if (concrete_base_table_ == NULL) concrete_base_table_ = new ::orion::bosen::task::ConcreteBaseTable;
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.ExecForLoop.concrete_base_table)
  return concrete_base_table_;
}
inline ::orion::bosen::task::ConcreteBaseTable* ExecForLoop::release_concrete_base_table() {
  clear_has_concrete_base_table();
  ::orion::bosen::task::ConcreteBaseTable* temp = concrete_base_table_;
  concrete_base_table_ = NULL;
  return temp;
}
inline void ExecForLoop::set_allocated_concrete_base_table(::orion::bosen::task::ConcreteBaseTable* concrete_base_table) {
  delete concrete_base_table_;
  concrete_base_table_ = concrete_base_table;
  if (concrete_base_table) {
    set_has_concrete_base_table();
  } else {
    clear_has_concrete_base_table();
  }
  // @@protoc_insertion_point(field_set_allocated:orion.bosen.task.ExecForLoop.concrete_base_table)
}

// repeated .orion.bosen.task.TableDep deps = 5;
inline int ExecForLoop::deps_size() const {
  return deps_.size();
}
inline void ExecForLoop::clear_deps() {
  deps_.Clear();
}
inline const ::orion::bosen::task::TableDep& ExecForLoop::deps(int index) const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.ExecForLoop.deps)
  return deps_.Get(index);
}
inline ::orion::bosen::task::TableDep* ExecForLoop::mutable_deps(int index) {
  // @@protoc_insertion_point(field_mutable:orion.bosen.task.ExecForLoop.deps)
  return deps_.Mutable(index);
}
inline ::orion::bosen::task::TableDep* ExecForLoop::add_deps() {
  // @@protoc_insertion_point(field_add:orion.bosen.task.ExecForLoop.deps)
  return deps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::orion::bosen::task::TableDep >&
ExecForLoop::deps() const {
  // @@protoc_insertion_point(field_list:orion.bosen.task.ExecForLoop.deps)
  return deps_;
}
inline ::google::protobuf::RepeatedPtrField< ::orion::bosen::task::TableDep >*
ExecForLoop::mutable_deps() {
  // @@protoc_insertion_point(field_mutable_list:orion.bosen.task.ExecForLoop.deps)
  return &deps_;
}

// required .orion.bosen.task.Repetition repetition = 6;
inline bool ExecForLoop::has_repetition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExecForLoop::set_has_repetition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExecForLoop::clear_has_repetition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExecForLoop::clear_repetition() {
  repetition_ = 1;
  clear_has_repetition();
}
inline ::orion::bosen::task::Repetition ExecForLoop::repetition() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.ExecForLoop.repetition)
  return static_cast< ::orion::bosen::task::Repetition >(repetition_);
}
inline void ExecForLoop::set_repetition(::orion::bosen::task::Repetition value) {
  assert(::orion::bosen::task::Repetition_IsValid(value));
  set_has_repetition();
  repetition_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.ExecForLoop.repetition)
}

// required uint64 num_iterations = 7;
inline bool ExecForLoop::has_num_iterations() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExecForLoop::set_has_num_iterations() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExecForLoop::clear_has_num_iterations() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExecForLoop::clear_num_iterations() {
  num_iterations_ = GOOGLE_ULONGLONG(0);
  clear_has_num_iterations();
}
inline ::google::protobuf::uint64 ExecForLoop::num_iterations() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.ExecForLoop.num_iterations)
  return num_iterations_;
}
inline void ExecForLoop::set_num_iterations(::google::protobuf::uint64 value) {
  set_has_num_iterations();
  num_iterations_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.ExecForLoop.num_iterations)
}

// required int32 result_type = 8;
inline bool ExecForLoop::has_result_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExecForLoop::set_has_result_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ExecForLoop::clear_has_result_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ExecForLoop::clear_result_type() {
  result_type_ = 0;
  clear_has_result_type();
}
inline ::google::protobuf::int32 ExecForLoop::result_type() const {
  // @@protoc_insertion_point(field_get:orion.bosen.task.ExecForLoop.result_type)
  return result_type_;
}
inline void ExecForLoop::set_result_type(::google::protobuf::int32 value) {
  set_has_result_type();
  result_type_ = value;
  // @@protoc_insertion_point(field_set:orion.bosen.task.ExecForLoop.result_type)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace task
}  // namespace bosen
}  // namespace orion

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::orion::bosen::task::TableDepType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::orion::bosen::task::TableDepType>() {
  return ::orion::bosen::task::TableDepType_descriptor();
}
template <> struct is_proto_enum< ::orion::bosen::task::ReadWrite> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::orion::bosen::task::ReadWrite>() {
  return ::orion::bosen::task::ReadWrite_descriptor();
}
template <> struct is_proto_enum< ::orion::bosen::task::Repetition> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::orion::bosen::task::Repetition>() {
  return ::orion::bosen::task::Repetition_descriptor();
}
template <> struct is_proto_enum< ::orion::bosen::task::PartitionScheme> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::orion::bosen::task::PartitionScheme>() {
  return ::orion::bosen::task::PartitionScheme_descriptor();
}
template <> struct is_proto_enum< ::orion::bosen::task::BaseTableType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::orion::bosen::task::BaseTableType>() {
  return ::orion::bosen::task::BaseTableType_descriptor();
}
template <> struct is_proto_enum< ::orion::bosen::task::DistArrayParentType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::orion::bosen::task::DistArrayParentType>() {
  return ::orion::bosen::task::DistArrayParentType_descriptor();
}
template <> struct is_proto_enum< ::orion::bosen::task::DistArrayInitType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::orion::bosen::task::DistArrayInitType>() {
  return ::orion::bosen::task::DistArrayInitType_descriptor();
}
template <> struct is_proto_enum< ::orion::bosen::task::DistArrayMapType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::orion::bosen::task::DistArrayMapType>() {
  return ::orion::bosen::task::DistArrayMapType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_task_2eproto__INCLUDED
